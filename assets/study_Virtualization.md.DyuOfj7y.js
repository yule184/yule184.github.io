import{_ as s,c as a,o as t,a2 as h}from"./chunks/framework.ZQz07f7Q.js";const n="/assets/state_change.DIhSXTx1.png",g=JSON.parse('{"title":"4.1 抽象：进程","description":"","frontmatter":{},"headers":[],"relativePath":"study/Virtualization.md","filePath":"study/Virtualization.md","lastUpdated":null}'),l={name:"study/Virtualization.md"};function k(p,i,e,r,d,E){return t(),a("div",null,[...i[0]||(i[0]=[h('<h1 id="_4-1-抽象-进程" tabindex="-1">4.1 抽象：进程 <a class="header-anchor" href="#_4-1-抽象-进程" aria-label="Permalink to &quot;4.1 抽象：进程&quot;">​</a></h1><h2 id="进程-process" tabindex="-1">进程 Process <a class="header-anchor" href="#进程-process" aria-label="Permalink to &quot;进程 Process&quot;">​</a></h2><blockquote><p>操作系统为正在运行的程序提供的抽象，就是所谓的进程。一个进程只是一个正在运行的程序。</p></blockquote><p><strong>进程的机器状态：进程可访问的内存（称为地址空间，address space ），寄存器</strong></p><blockquote><p>特殊的寄存器：程序寄存器PC，栈指针sp，帧指针fp</p></blockquote><h1 id="_4-2-进程api" tabindex="-1">4.2 进程API <a class="header-anchor" href="#_4-2-进程api" aria-label="Permalink to &quot;4.2 进程API&quot;">​</a></h1><p>所有现代操作系统都以某种形式提供这些API</p><ul><li><strong>创建 create</strong> 操作系统必须包含一些创建新进程的方法</li><li><strong>销毁 destroy</strong> 强制销毁进程的接口</li><li><strong>等待 wait</strong></li><li><strong>其他控制 miscellaneous control 除</strong>了杀死或等待进程外，还可能有其他控制，例如暂停进程然后恢复</li><li><strong>状态 status</strong> 获得有关进程的状态信息</li></ul><h1 id="_4-3-进程创建-更多细节" tabindex="-1">4.3 进程创建：更多细节 <a class="header-anchor" href="#_4-3-进程创建-更多细节" aria-label="Permalink to &quot;4.3 进程创建：更多细节&quot;">​</a></h1><h2 id="加载-load" tabindex="-1">加载 load <a class="header-anchor" href="#加载-load" aria-label="Permalink to &quot;加载 load&quot;">​</a></h2><p>操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载到内存中，加载到进程的地址空间中（操作系统从磁盘读取这些字节，并将它们放在内存中单某处）</p><blockquote><p>代码和数据的惰性加载如何工作：分页和交换机制</p></blockquote><h2 id="分配内存" tabindex="-1">分配内存 <a class="header-anchor" href="#分配内存" aria-label="Permalink to &quot;分配内存&quot;">​</a></h2><p>比如为程序的运行时栈（run-time stack 或 stack）分配一些内存。</p><p>C程序使用栈存放局部变量、函数参数和返回地址，操作系统分配内存并提供给进程；为程序的堆（heap）也奉陪内存，用于显式请求的动态分配数据</p><h2 id="其他初始化任务" tabindex="-1">其他初始化任务 <a class="header-anchor" href="#其他初始化任务" aria-label="Permalink to &quot;其他初始化任务&quot;">​</a></h2><p>与输入/输出（I/O）相关的任务，如文件操作符</p><h2 id="启动程序" tabindex="-1">启动程序 <a class="header-anchor" href="#启动程序" aria-label="Permalink to &quot;启动程序&quot;">​</a></h2><p>跳转到main()例程，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行</p><h1 id="_4-4-进程状态" tabindex="-1">4.4 进程状态 <a class="header-anchor" href="#_4-4-进程状态" aria-label="Permalink to &quot;4.4 进程状态&quot;">​</a></h1><ul><li><strong>运行 running</strong>正在执行指令</li><li><strong>就绪 ready</strong>进程已准备好运行，但由于某种原因，操作系统选择不在此时运行</li><li><strong>阻塞 block</strong> 一个进程执行了某种操作，直到发生其他事件时才会准备运行</li></ul><p><img src="'+n+`" alt="进程：状态转换"></p><h1 id="_4-5-数据结构" tabindex="-1">4.5 数据结构 <a class="header-anchor" href="#_4-5-数据结构" aria-label="Permalink to &quot;4.5 数据结构&quot;">​</a></h1><blockquote><p>xv6的proc结构</p></blockquote><p>操作系统他跟踪进程的一些重要信息。对于停止的进程，寄存器上下文将保存其寄存器的内容，当一个进程停止时，它的寄存器将被保存到这个内存位置，通过回复这些寄存器，可以恢复运行该进程。（<strong>上下文切换 context switch</strong>）</p><ul><li>除了运行、就绪和阻塞以外，还有其他一些进程可以处于的状态。 <ul><li>initial 初始状态，表示进程在创建时处于的装填</li><li>final 已退出但尚未清理的罪状状态（UNIX系统中，成为僵尸状态）。允许其他进程（父进程）检查进程的返回代码并查看刚刚完成的进程是否成功执行，完成后父进程将进行最后一次调用如wait()以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构</li></ul></li></ul><p>有时候人们会将存储关于进程的信息的个体结构成为进程控制块（PCB）</p><h1 id="_5-1-fork-系统调用" tabindex="-1">5.1 fork()系统调用 <a class="header-anchor" href="#_5-1-fork-系统调用" aria-label="Permalink to &quot;5.1 fork()系统调用&quot;">​</a></h1><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;usistd.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello world (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //  fork failed;exit</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        fprintf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stderr,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fork failed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // child(new process)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,I am child(pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // parent goes down this path(main)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,I am parent of </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,rc,(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>系统调用fork()用于创建新进程，对操作系统来说，看起来有两个完全一样的p1程序在运行，并且都从fork()系统调用中返回。新创建的进程称为子进程，原来的进程称为父进程。子进程不会从main()函数开始执行，而是直接从fork()系统调用返回，就好像是它自己调用了fork()。</p><p>子进程虽然有自己的地址空间（私有内存），寄存器，程序计数器，但它从fork()返回的字时不同的。父进程获得的返回值是新创建子进程的pid，而子进程获得的返回值是0。</p><h1 id="_5-2-wait-系统调用" tabindex="-1">5.2 wait()系统调用 <a class="header-anchor" href="#_5-2-wait-系统调用" aria-label="Permalink to &quot;5.2 wait()系统调用&quot;">​</a></h1><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;unistd.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sys/wait.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello world (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        fprintf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stderr,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fork failed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,I am child (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,I am parent of </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> (wc:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">) (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,rc, wc, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>父进程调用wait()，延迟自己的执行，直到子进程执行完毕，当子进程结束时，wait()才返回父进程。因此增加wait()调用后，输出结果变得确定了，子进程总是先输出结果</p><h1 id="_5-3-exec-系统调用" tabindex="-1">5.3 exec()系统调用 <a class="header-anchor" href="#_5-3-exec-系统调用" aria-label="Permalink to &quot;5.3 exec()系统调用&quot;">​</a></h1><p>exec()系统调用可以让子进程执行与父进程不同的程序。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;unistd.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;string.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sys/wait.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello world (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        fprintf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stderr,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fork failed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,I am child (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> myargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        myargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strdup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;wc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // program:&quot;wc&quot;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        myargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strdup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;p3.c&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // argument: file to count</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        myargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        execvp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">myargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],myargs);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;this shouldn&#39;t print out</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello,I am parent of </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> (wc:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">) (pid:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,rc, wc, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>子进程调用execvp()来运行字符技术程序wc，实际上，它针对源代码文件p3.c运行wc。execvp()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段以及静态数据，堆栈及其他内存空间也会被重新初始化。</p><p>它没有创建新进程，而是直接将当前运行的程序（以前的p3）替换为不同的运行程序。子进程执行exec()之后，几乎就像p3.c从未运行过一样，对exec()的成功调用永远不会返回。</p><p>chapter 6 机制：受限直接执行</p><h1 id="_6-1-基本技巧-受限直接执行-limited-direct-execution" tabindex="-1">6.1 基本技巧：受限直接执行 limited direct execution <a class="header-anchor" href="#_6-1-基本技巧-受限直接执行-limited-direct-execution" aria-label="Permalink to &quot;6.1 基本技巧：受限直接执行 limited direct execution&quot;">​</a></h1><table tabindex="0"><thead><tr><th>操作系统</th><th>程序</th></tr></thead><tbody><tr><td>在进程列表上创建条目<br>为程序分配内存<br>将程序加载到内存中<br>根据argc/argv设置程序栈</td><td></td></tr><tr><td>清楚寄存器<br>执行call main()方法</td><td></td></tr><tr><td></td><td>执行main()<br>从main中执行return</td></tr><tr><td>释放进程的内存给进程<br>从进程列表中清楚</td><td></td></tr></tbody></table><p>这是基本的直接执行协议（没有任何限制）</p><h1 id="_6-2-问题1-受限制的操作" tabindex="-1">6.2 问题1：受限制的操作 <a class="header-anchor" href="#_6-2-问题1-受限制的操作" aria-label="Permalink to &quot;6.2 问题1：受限制的操作&quot;">​</a></h1><p>如果进程希望执行某种受限操作，如向磁盘发出I/O请求或获得更多系统资源（如CPU或内存）</p><p>引入一种新的处理器模式，<strong>用户模式（user node）</strong>，在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出I/O请求，这样做会导致处理器引发异常，操作系统可能会终止进程。</p><p>与用户模式不同的<strong>内核模式（kernel mode）</strong>，操作系统或内核就以这种模式运行。在此模式下，代码可以执行特权操作，如发出I/O请求和执行所有类型的受限指令。</p><p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令，该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核模式，系统就可以执行任何需要的特权操作，从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回的指令，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</p><p>内核通过在启动时设置陷阱表，告诉硬件在发生某些异常事件时要运行哪些代码</p><table tabindex="0"><thead><tr><th>操作系统@运行（内核模式）</th><th>硬件</th></tr></thead><tbody><tr><td>初始化陷阱表</td><td></td></tr><tr><td></td><td>记住系统调用处理程序的地址</td></tr></tbody></table><table tabindex="0"><thead><tr><th>操作系统@运行（内核模式）</th><th>硬件</th><th>程序（应用模式）</th></tr></thead><tbody><tr><td>在进程列表上创建条目<br>为程序分配内存<br>将程序加载到内存中<br>根据argv设置程序栈<br>用寄存器/程序计数器填充内核栈<br>从陷阱返回</td><td></td><td></td></tr><tr><td></td><td>从内核栈恢复寄存器<br>转向用户模式<br>跳到main</td><td></td></tr><tr><td></td><td></td><td>运行main<br>......<br>调用系统调用<br>陷入操作系统</td></tr><tr><td></td><td>将寄存器保存到内核栈<br>转向内核模式<br>跳到陷阱处理程序</td><td></td></tr><tr><td>处理陷阱<br>做系统调用的工作<br>从陷阱返回</td><td></td><td></td></tr><tr><td></td><td>从内核栈恢复寄存器<br>转向用户模式<br>跳到陷阱之后的程序寄存器</td><td></td></tr><tr><td></td><td></td><td>......从main返回<br>陷入（通过exit()）</td></tr><tr><td>释放进程的内存<br>将进程从进程列表中删除</td><td></td><td></td></tr></tbody></table><h1 id="_6-3-问题2-在进程之间切换" tabindex="-1">6.3 问题2：在进程之间切换 <a class="header-anchor" href="#_6-3-问题2-在进程之间切换" aria-label="Permalink to &quot;6.3 问题2：在进程之间切换&quot;">​</a></h1><blockquote><p>关键问题：如何重获CPU的控制权</p><p>操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换</p></blockquote><h2 id="协同方式-等待系统调用" tabindex="-1">协同方式：等待系统调用 <a class="header-anchor" href="#协同方式-等待系统调用" aria-label="Permalink to &quot;协同方式：等待系统调用&quot;">​</a></h2><p>大多数进程通过系统调用，将CPU的控制权转移给操作系统，像这样的系统通常包括一个显式的yield系统调用，它什么都不干，只是将控制权交给操作系统，以便系统可以运行其他进程。</p><p>如果应用呈持续执行了某些非法操作，也会将控制转移给操作系统。</p><h2 id="非协同方式-操作系统进行控制" tabindex="-1">非协同方式：操作系统进行控制 <a class="header-anchor" href="#非协同方式-操作系统进行控制" aria-label="Permalink to &quot;非协同方式：操作系统进行控制&quot;">​</a></h2><blockquote><p>即时进程不协作，操作系统如何获得CPU的控制权？操作系统可以做什么来确保流氓进程不会占用机器？</p></blockquote><p>**时钟中断：**时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在进行的进程停止，操作系统中预先配置的中断处理程序会运行，操作系统重新获得CPU的控制权。</p><ol><li>操作系统必须通知硬件哪些代码在发生时钟中断时运行</li><li>操作系统也必须启动时钟</li></ol><h2 id="保存和恢复上下文" tabindex="-1">保存和恢复上下文 <a class="header-anchor" href="#保存和恢复上下文" aria-label="Permalink to &quot;保存和恢复上下文&quot;">​</a></h2><p><strong>上下文切换 context switch：</strong> 操作系统为当前正在执行的进程保留一些寄存器的值（比如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。</p><p>这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p><ul><li>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。</li><li>通过切换栈，内核再进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文，</li><li>当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</li></ul><table tabindex="0"><thead><tr><th>操作系统@启动（内核模式）</th><th>硬件</th></tr></thead><tbody><tr><td>初始化陷阱表</td><td></td></tr><tr><td></td><td>记住以下位置：系统调用处理程序，时钟处理程序</td></tr><tr><td>启动中断时钟</td><td></td></tr><tr><td></td><td>启动时钟<br>每隔x ms中断CPU</td></tr></tbody></table><table tabindex="0"><thead><tr><th>操作系统@运行（内核模式）</th><th>硬件</th><th>程序（应用模式）</th></tr></thead><tbody><tr><td></td><td></td><td>进程A.....</td></tr><tr><td></td><td>时钟中断<br>将寄存器（A）保存到内核栈（A）<br>转向内核模式<br>跳到陷阱处理程序</td><td></td></tr><tr><td>处理陷阱<br>调用switch()例程<br>+ 将寄存器（A）保存到进程结构（A）<br>+ 将进程结构（B）恢复到寄存器（B）<br>从陷阱返回（进入B）</td><td></td><td></td></tr><tr><td></td><td>从内核栈（B）恢复寄存器（B）<br>转向用户模式<br>跳到B的程序计数器</td><td></td></tr><tr><td></td><td></td><td>进程B......</td></tr></tbody></table><p>有两种类型的寄存器保存/恢复</p><ul><li>发生时钟中断：运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈</li><li>操作系统决定从A切换到B：内核寄存器被软件（即OS）明确地保存，但这次被存储在该进程的进程结构的内存中。</li></ul><h1 id="_7-3-先进先出-fifo" tabindex="-1">7.3 先进先出 FIFO <a class="header-anchor" href="#_7-3-先进先出-fifo" aria-label="Permalink to &quot;7.3 先进先出 FIFO&quot;">​</a></h1><p>周转时间：任务完成时间-任务到达系统的时间。这是一个性能指标。</p><p><strong>护航效应</strong>：一些耗时较少的潜在资源消费者排在重量级的资源消费者之后。</p><h1 id="_7-4-最短任务有限-sjf" tabindex="-1">7.4 最短任务有限 SJF <a class="header-anchor" href="#_7-4-最短任务有限-sjf" aria-label="Permalink to &quot;7.4 最短任务有限 SJF&quot;">​</a></h1><p>先运行最短的任务，然后是次短的任务，如此下去。SJF是一个最优调度算法，且是非抢占式。</p><blockquote><p>抢占式调度程序vs非抢占式调度程序</p><p>非抢占式：会将每项工作做完，再考虑是否运行新工作</p><p>抢占式：可以进行上下文切换，临时停止一个进程，并恢复（或启动）另一个进程</p></blockquote><h1 id="_7-5-最短完成时间有限-stcf" tabindex="-1">7.5 最短完成时间有限 STCF <a class="header-anchor" href="#_7-5-最短完成时间有限-stcf" aria-label="Permalink to &quot;7.5 最短完成时间有限 STCF&quot;">​</a></h1><p>向SJF添加抢占：每当新工作进入系统时，它就会确认剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。考虑到如果所有工作同时到达，SJF是最优的，STCF的最优性是符合直觉的。</p><p>如果知道任务时长，而且任务只使用CPU，而唯一的衡量是周转时间，STCF是一个很好的策略</p><h1 id="_7-6-新度量指标-响应时间" tabindex="-1">7.6 新度量指标：响应时间 <a class="header-anchor" href="#_7-6-新度量指标-响应时间" aria-label="Permalink to &quot;7.6 新度量指标：响应时间&quot;">​</a></h1><p>响应时间：任务到达系统到首次运行的时间</p><p>STCF和相关方法再响应时间上并不是很好，如何构建对响应时间敏感的调度程序</p><h1 id="_7-7-轮转-round-robin-rr调度" tabindex="-1">7.7 轮转 Round-Robin/RR调度 <a class="header-anchor" href="#_7-7-轮转-round-robin-rr调度" aria-label="Permalink to &quot;7.7 轮转 Round-Robin/RR调度&quot;">​</a></h1><p>RR在一个时间片（time slice，有时称为调度量子）内运行一个工作，然后切换到运行队列的下一个任务，而不是运行一个任务直到结束。它反复执行，知道所有任务完成。因此，RR有时被称为时间切片。</p><blockquote><p>请注意：时间片长度必须是时钟中断周期的倍数</p></blockquote><p>时间片长度对于RR是至关重要的。越短，RR在响应时间上表现越好，然而时间片太短，突然上下文切换的成本将影响整体性能。系统设计这需要权衡时间片的长度，使其足够长，以便摊销上下文切换成本，而又不会使系统不及时响应。</p><blockquote><p>上下文切换的成本不仅仅来自于保存和恢复少量寄存器的操作系统操作。 程序运行时，它们在CPU高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。 切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本</p></blockquote><p>如果响应时间是唯一指标，带有合理时间片的RR会是很好的调度程序，但如果周转时间是指标，RR十分糟糕。RR所作的正是延伸每个工作，只运行每个工作一小段时间，就转向下一个工作。周转时间只关系作业何时完成，RR几乎是最差的。</p><p>更一般地说，任何公平（fair）的政策，即在小规模的时间内将CPU均匀分配到活动进程中，在周转时间这类指标上表现不佳</p><h1 id="_7-8-结合i-o" tabindex="-1">7.8 结合I/O <a class="header-anchor" href="#_7-8-结合i-o" aria-label="Permalink to &quot;7.8 结合I/O&quot;">​</a></h1><p>调度程序需要在工作发起I/O请求时做出决定，因为当前正在运行的作业在I/O期间不会使用CPU，它被阻塞等待I/O完成。如果将I/O发送到硬盘驱动器，则该进程可能会被阻塞几秒钟或更长时间，具体取决于驱动器当前的I/O负载。因此，这时调度程序应该在CPU上安排另一项工作。</p><p>调度程序还必须在I/O完成时做出决定。发生这种情况时，会产生中断，操作系统运行并将发出I/O的进程从阻塞状态移回就绪状态。</p><p>重叠：一个进程在等待另一个进程的I/O完成时使用CPU，系统因此得到更好的利用。</p><p>通过将每个CPU突发作为一项工作，调度程序确保“交互”的进程经常运行，从而更好地利用处理器。</p><h1 id="_8-1-多级反馈队列-mlfq-基本规则" tabindex="-1">8.1 多级反馈队列 MLFQ：基本规则 <a class="header-anchor" href="#_8-1-多级反馈队列-mlfq-基本规则" aria-label="Permalink to &quot;8.1 多级反馈队列 MLFQ：基本规则&quot;">​</a></h1><p>MLFQ中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个工作中，MLFQ总是优先执行较高优先级的工作（即在较高级队列中的工作）。每个队列中可能会有多个工作，因此具有同样的优先级，对这些工作采用轮转调度。</p><p>MLFQ调度策略的关键在于如何设置优先级，它根据观察到的行为调整优先级。</p><ul><li>如果一个工作不断放弃CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。</li><li>相反，如果一个工作长时间地占用CPU，MLFQ会降低其优先级。通过这种方式，MLFQ在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。</li></ul><p>MLFQ的两条基本规则：</p><ol><li>如果A的优先级＞B的优先级，运行A（不运行B）</li><li>如果A的优先级=B的优先级，轮转运行A和B</li></ol><h1 id="_8-2-尝试1-如何改变优先级" tabindex="-1">8.2 尝试1：如何改变优先级 <a class="header-anchor" href="#_8-2-尝试1-如何改变优先级" aria-label="Permalink to &quot;8.2 尝试1：如何改变优先级&quot;">​</a></h1><p>工作负载：既有运行时间很短、频繁放弃CPU的交互型工作，也有需要很多CPU时间、响应时间却不重要的长时间计算密集型工作。</p><h2 id="调整1" tabindex="-1">调整1 <a class="header-anchor" href="#调整1" aria-label="Permalink to &quot;调整1&quot;">​</a></h2><ul><li>规则3：工作进入系统时，放在最高优先级（最上层队列）</li><li>规则4a：工作用完整个时间片后，降低其优先级（移入下一个队列）</li><li>规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变</li></ul><p>主要目标：如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，让交互型工作快速运行。否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF。</p><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><ul><li><strong>饥饿问题</strong>。如果系统有太多交互型工作，就会不断占用CPU，导致长工作永远无法得到CPU（它们饿死了）</li><li><strong>重写程序，愚弄调度程序</strong>（game the scheduler）。用一些卑鄙的手段欺骗调度程序，让它提供远超公平的资源。 <ul><li>进程在时间片用完前，调用一个I/O操作（比如访问一个无关 的文件），从而主动释放CPU，如此便可以保持在高优先级，占用更多的CPU时间，做的好时几乎可以独占CPU。</li></ul></li><li><strong>程序可能在不同时间表现不同</strong>。一个计算密集型的程序可能在某段时间表现为一个交互型的程序。</li></ul><h1 id="_8-3-尝试2-提升优先级" tabindex="-1">8.3 尝试2：提升优先级 <a class="header-anchor" href="#_8-3-尝试2-提升优先级" aria-label="Permalink to &quot;8.3 尝试2：提升优先级&quot;">​</a></h1><h2 id="新规则" tabindex="-1">新规则 <a class="header-anchor" href="#新规则" aria-label="Permalink to &quot;新规则&quot;">​</a></h2><ul><li>规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列</li></ul><p>首先，进程不会饿死——在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享CPU，从而最终获得执行。</p><p>其次，如果一个CPU密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。</p><h2 id="问题-1" tabindex="-1">问题 <a class="header-anchor" href="#问题-1" aria-label="Permalink to &quot;问题&quot;">​</a></h2><p>S的值应该如何设置？S设置得太高，长工作会饥饿；设置得太低，交互型工作又得不到合适的CPU时间比例。</p><h1 id="_8-4-尝试3-更好的计时方式" tabindex="-1">8.4 尝试3：更好的计时方式 <a class="header-anchor" href="#_8-4-尝试3-更好的计时方式" aria-label="Permalink to &quot;8.4 尝试3：更好的计时方式&quot;">​</a></h1><p>如何阻止调度程序被愚弄？</p><ul><li>为MLFQ的每层队列提供更完善的CPU计时方式。调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进程用完了自己的配额，就将它降到低一优先级的队列中去。</li></ul><h2 id="重写" tabindex="-1">重写 <a class="header-anchor" href="#重写" aria-label="Permalink to &quot;重写&quot;">​</a></h2><ul><li>规则4： 一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</li></ul><h1 id="_9-1-基本概念-彩票数表示份额" tabindex="-1">9.1 基本概念：彩票数表示份额 <a class="header-anchor" href="#_9-1-基本概念-彩票数表示份额" aria-label="Permalink to &quot;9.1 基本概念：彩票数表示份额&quot;">​</a></h1><blockquote><p>比例份额调度程序基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。</p><p>彩票调度：每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。</p></blockquote><p>彩票数代表了进程占有每个资源的份额，一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。通过不断定时地抽取彩票，彩票调度从概率上（但不是确定的）获得这种份额比例。</p><h1 id="_9-2-彩票机制" tabindex="-1">9.2 彩票机制 <a class="header-anchor" href="#_9-2-彩票机制" aria-label="Permalink to &quot;9.2 彩票机制&quot;">​</a></h1><p>调度彩票：</p><ol><li>彩票货币（ticket currency）：允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作，之后操作系统再自动将这种货币兑换为正确的全局彩票。</li><li>彩票转让（ticket transfer）：通过转让，一个进程可以临时将自己的彩票交给另一个进程。客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行，客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服务端执行结束后会将这部分彩票归还给客户端。</li><li>彩票通胀（ticket inflation）：利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量（在竞争环境中，进程之间相互不信任，这种既指就没什么意义，一个贪婪的进程可能给自己非常多的彩票，从而接管机票）</li></ol><h1 id="_9-3-实现" tabindex="-1">9.3 实现 <a class="header-anchor" href="#_9-3-实现" aria-label="Permalink to &quot;9.3 实现&quot;">​</a></h1><p>一个随机数生成器选择中奖彩票，一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。建议将列表项按照票数递减排序。</p><p>当工作执行时间很短时，平均不公平度非常糟糕。只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。</p><h1 id="_9-6-为什么是不确定的" tabindex="-1">9.6 为什么是不确定的 <a class="header-anchor" href="#_9-6-为什么是不确定的" aria-label="Permalink to &quot;9.6 为什么是不确定的&quot;">​</a></h1><p>步长调度（stride scheduling）：一个确定性的公平分配算法。</p><p>系统中的每个工作都有自己的步长，和票数值成反比。每次进程运行候，会让它的计数器/进程值pass值增加步长，记录它的总体进展。之后，调度程序使用进程的步长及行程值来确定调度哪个进程。</p><ul><li>需要进行调度时，选择目前拥有最小进程值的进程，并且在运行后将该进程的行程值增加一个步长。</li></ul><p>相比之下彩票调度的优势：不需要全局状态，只需要用新进程的票数更新全局的总票数就可以了。</p>`,131)])])}const o=s(l,[["render",k]]);export{g as __pageData,o as default};
