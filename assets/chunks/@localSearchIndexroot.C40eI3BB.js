const t='{"documentCount":176,"nextId":176,"documentIds":{"0":"/about.html#关于-corner-note","1":"/about.html#🍂-关于这个角落","2":"/about.html#📖-我是谁","3":"/about.html#📝-内容分类","4":"/about.html#思维碎片","5":"/about.html#灵感源泉","6":"/about.html#迭代成长","7":"/about.html#🌟-写作原则","8":"/about.html#💫-联系我","9":"/api-examples.html#runtime-api-examples","10":"/api-examples.html#results","11":"/api-examples.html#theme-data","12":"/api-examples.html#page-data","13":"/api-examples.html#page-frontmatter","14":"/api-examples.html#more","15":"/creation/今日无事.html#今日无事","16":"/creation/#创作实验","17":"/life/#随笔角落","18":"/life/#最新随笔","19":"/life/#按标签浏览","20":"/life/九月小记.html#九月小记","21":"/markdown-examples.html#markdown-extension-examples","22":"/markdown-examples.html#syntax-highlighting","23":"/markdown-examples.html#custom-containers","24":"/markdown-examples.html#more","25":"/study/CoreConceptsOfAT.html#软件测试核心概念","26":"/study/CoreConceptsOfAT.html#_1-什么是软件质量","27":"/study/CoreConceptsOfAT.html#_2-什么是软件缺陷-它具有哪些危害-如何管理","28":"/study/CoreConceptsOfAT.html#软件缺陷的定义","29":"/study/CoreConceptsOfAT.html#缺陷管理流程","30":"/study/CoreConceptsOfAT.html#_3-什么是软件测试","31":"/study/CoreConceptsOfAT.html#_4-测试的普遍性","32":"/study/CoreConceptsOfAT.html#_5-软件测试的种类","33":"/study/CoreConceptsOfAT.html#_6-软件测试的关键问题是什么","34":"/study/CoreConceptsOfAT.html#软件生命周期8阶段","35":"/study/CoreConceptsOfAT.html#四个关键方面","36":"/study/CoreConceptsOfAT.html#_7-软件测试的对象是什么","37":"/study/CoreConceptsOfAT.html#_8-软件测试的停止准则有哪些","38":"/study/CoreConceptsOfAT.html#_9-软件测试的周期性和并行性","39":"/study/CoreConceptsOfAT.html#_10-软件测试的目的、意义和原则","40":"/study/CoreConceptsOfAT.html#目的","41":"/study/CoreConceptsOfAT.html#意义","42":"/study/CoreConceptsOfAT.html#_11-软件测试的未来发展趋势","43":"/study/CoreConceptsOfAT.html#_12-软件测试在软件工程中的位置","44":"/study/CoreConceptsOfAT.html#_13-软件测试的模型","45":"/study/CoreConceptsOfAT.html#v模型","46":"/study/CoreConceptsOfAT.html#w模型","47":"/study/CoreConceptsOfAT.html#x模型","48":"/study/CoreConceptsOfAT.html#_14-软件测试的过程-测试信息流程","49":"/study/CoreConceptsOfAT.html#_15-软件测试的研究进展","50":"/study/CoreConceptsOfAT.html#_16-软件测试作为一种职业和科学","51":"/study/CoreConceptsOfAT.html#_17-软件测试的工具分类","52":"/study/CoreConceptsOfAT.html#_18-软件测试的管理框架","53":"/study/CoreConceptsOfAT.html#时间维-全过程管理","54":"/study/CoreConceptsOfAT.html#空间维-全方位管理","55":"/study/CoreConceptsOfAT.html#组织维-人员管理","56":"/study/CoreConceptsOfAT.html#_19-软件测试的历史演进","57":"/study/CoreConceptsOfAT.html#_20-软件测试的标准规范","58":"/study/CoreConceptsOfAT.html#_21-解释软件的故障模型pie","59":"/study/CoreConceptsOfAT.html#pie名称由来","60":"/study/CoreConceptsOfAT.html#三个层次","61":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#需求与商业模式创新","62":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#lesson-2-互联网-软件运营原理-商业模式类型-平台、免费","63":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#多边平台商业模式-促进群体互动创造价值","64":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#谷歌的商业模式-平台推广","65":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#当前的主流互联网产品基本都是多边平台商业模式","66":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#多边平台商业模式总结","67":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#免费的商业模式-其他方面补贴免费产品","68":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#广告-一个多边平台商业模式","69":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#免费增值","70":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#保险-倒转的免费增值","71":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#免费增值模式总结","72":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#反转免费模式举例-cookpad食谱网站","73":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#诱饵-陷阱","74":"/study/Note 2 互联网+软件运营原理 商业模式类型-平台、免费.html#总结","75":"/study/Virtualization.html#_4-1-抽象-进程","76":"/study/Virtualization.html#进程-process","77":"/study/Virtualization.html#_4-2-进程api","78":"/study/Virtualization.html#_4-3-进程创建-更多细节","79":"/study/Virtualization.html#加载-load","80":"/study/Virtualization.html#分配内存","81":"/study/Virtualization.html#其他初始化任务","82":"/study/Virtualization.html#启动程序","83":"/study/Virtualization.html#_4-4-进程状态","84":"/study/Virtualization.html#_4-5-数据结构","85":"/study/Virtualization.html#_5-1-fork-系统调用","86":"/study/Virtualization.html#_5-2-wait-系统调用","87":"/study/Virtualization.html#_5-3-exec-系统调用","88":"/study/Virtualization.html#_6-1-基本技巧-受限直接执行-limited-direct-execution","89":"/study/Virtualization.html#_6-2-问题1-受限制的操作","90":"/study/Virtualization.html#_6-3-问题2-在进程之间切换","91":"/study/Virtualization.html#协同方式-等待系统调用","92":"/study/Virtualization.html#非协同方式-操作系统进行控制","93":"/study/Virtualization.html#保存和恢复上下文","94":"/study/Virtualization.html#_7-3-先进先出-fifo","95":"/study/Virtualization.html#_7-4-最短任务有限-sjf","96":"/study/Virtualization.html#_7-5-最短完成时间有限-stcf","97":"/study/Virtualization.html#_7-6-新度量指标-响应时间","98":"/study/Virtualization.html#_7-7-轮转-round-robin-rr调度","99":"/study/Virtualization.html#_7-8-结合i-o","100":"/study/Virtualization.html#_8-1-多级反馈队列-mlfq-基本规则","101":"/study/Virtualization.html#_8-2-尝试1-如何改变优先级","102":"/study/Virtualization.html#调整1","103":"/study/Virtualization.html#问题","104":"/study/Virtualization.html#_8-3-尝试2-提升优先级","105":"/study/Virtualization.html#新规则","106":"/study/Virtualization.html#问题-1","107":"/study/Virtualization.html#_8-4-尝试3-更好的计时方式","108":"/study/Virtualization.html#重写","109":"/study/Virtualization.html#_9-1-基本概念-彩票数表示份额","110":"/study/Virtualization.html#_9-2-彩票机制","111":"/study/Virtualization.html#_9-3-实现","112":"/study/Virtualization.html#_9-6-为什么是不确定的","113":"/study/concurrent.html#_26-1-实例-线程创建","114":"/study/concurrent.html#_26-2-为什么更糟糕-共享数据","115":"/study/concurrent.html#_26-3-核心问题-不可控的调度","116":"/study/concurrent.html#_26-4-原子性愿望","117":"/study/concurrent.html#_26-5-还有一个问题-等待另一个线程","118":"/study/concurrent.html#_27-1-线程创建","119":"/study/concurrent.html#_27-2-线程完成","120":"/study/concurrent.html#_27-3-锁","121":"/study/concurrent.html#_27-4-条件变量-condition-variable","122":"/study/concurrent.html#_27-5-编译和运行","123":"/study/concurrent.html#_28-1-锁的基本思想","124":"/study/concurrent.html#_28-2-pthread锁","125":"/study/concurrent.html#_28-3-实现一个锁","126":"/study/concurrent.html#_28-4-评价锁","127":"/study/concurrent.html#_28-5-控制中断","128":"/study/concurrent.html#_28-6-测试并设置指令-原子交换","129":"/study/concurrent.html#尝试1","130":"/study/concurrent.html#_28-7-实现可用的自旋锁-spin-lock","131":"/study/concurrent.html#_28-8-评价自旋锁","132":"/study/concurrent.html#_28-9-比较并交换","133":"/study/concurrent.html#_28-10-链接的加载和条件式存储指令","134":"/study/concurrent.html#_28-11-获取并增加","135":"/study/concurrent.html#_28-12-自旋过多-怎么办","136":"/study/concurrent.html#_28-13-简单方法-让出来吧-宝贝","137":"/study/concurrent.html#_28-14-使用队列-休眠替代自旋","138":"/study/concurrent.html#_28-15-不同操作系统-不同实现","139":"/study/concurrent.html#_28-16-两阶段锁","140":"/study/concurrent.html#_29-1-并发计数器","141":"/study/concurrent.html#简单但无法扩展","142":"/study/concurrent.html#可扩展的计数","143":"/study/concurrent.html#_29-2-并发链表","144":"/study/concurrent.html#扩展列表","145":"/study/concurrent.html#_29-3-并发队列","146":"/study/concurrent.html#_29-4-并发散列表","147":"/study/concurrent.html#_30-1-条件变量定义和程序","148":"/study/concurrent.html#_30-2-生产者-消费者-有界缓冲区-问题","149":"/study/concurrent.html#单值缓冲区的生产者-消费者问题","150":"/study/concurrent.html#最终的生产者-消费者方案","151":"/study/concurrent.html#_30-3-覆盖条件-covering-condition","152":"/study/concurrent.html#_31-1-信号量的定义","153":"/study/concurrent.html#_31-2-二值信号量-锁","154":"/study/concurrent.html#_31-3-信号量用作条件变量","155":"/study/concurrent.html#_31-4-生产者-消费者-有界缓冲区-问题","156":"/study/concurrent.html#_31-5-读者-写者锁","157":"/study/concurrent.html#_31-6-哲学家就餐问题","158":"/study/concurrent.html#一种方案-破除依赖","159":"/study/concurrent.html#_32-2-非死锁缺陷","160":"/study/concurrent.html#违反原子性缺陷-atomicity-violation","161":"/study/concurrent.html#违反顺序缺陷-order-violation","162":"/study/concurrent.html#_32-3-死锁缺陷-deadlock","163":"/study/concurrent.html#为什么发生死锁","164":"/study/concurrent.html#产生死锁的条件","165":"/study/concurrent.html#预防","166":"/study/concurrent.html#循环等待","167":"/study/concurrent.html#持有并等待","168":"/study/concurrent.html#非抢占","169":"/study/concurrent.html#互斥","170":"/study/concurrent.html#通过调度避免死锁","171":"/study/concurrent.html#银行家算法","172":"/study/concurrent.html#检查和恢复","173":"/study/#学习笔记","174":"/study/#最新笔记","175":"/study/#按标签浏览"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[3,1,6],"1":[2,3,84],"2":[2,3,4],"3":[2,3,1],"4":[1,5,3],"5":[1,5,4],"6":[1,5,3],"7":[2,3,9],"8":[2,3,17],"9":[3,1,51],"10":[1,3,1],"11":[2,4,2],"12":[2,4,2],"13":[2,4,2],"14":[1,3,11],"15":[1,1,4],"16":[1,1,1],"17":[1,1,3],"18":[1,1,11],"19":[1,1,5],"20":[1,1,4],"21":[3,1,14],"22":[2,3,26],"23":[2,3,21],"24":[1,3,11],"25":[1,1,1],"26":[2,1,6],"27":[5,1,1],"28":[2,6,13],"29":[2,6,8],"30":[2,1,9],"31":[2,1,17],"32":[2,1,19],"33":[3,1,1],"34":[2,4,11],"35":[2,4,5],"36":[2,1,7],"37":[2,1,12],"38":[2,1,8],"39":[3,1,1],"40":[1,4,10],"41":[1,4,5],"42":[2,1,13],"43":[2,1,8],"44":[2,1,1],"45":[1,3,1],"46":[1,3,1],"47":[1,3,1],"48":[4,1,1],"49":[2,1,8],"50":[2,1,10],"51":[2,1,8],"52":[2,1,1],"53":[2,3,5],"54":[2,3,8],"55":[2,3,3],"56":[2,1,18],"57":[2,1,22],"58":[2,1,6],"59":[2,3,10],"60":[2,3,8],"61":[1,1,1],"62":[6,1,31],"63":[2,7,11],"64":[2,9,7],"65":[1,9,27],"66":[1,9,18],"67":[2,7,19],"68":[2,9,13],"69":[1,9,28],"70":[2,9,4],"71":[1,9,31],"72":[2,9,4],"73":[3,9,33],"74":[1,7,12],"75":[4,1,1],"76":[2,4,14],"77":[3,1,19],"78":[4,1,1],"79":[2,4,9],"80":[1,4,14],"81":[1,4,7],"82":[1,4,5],"83":[2,1,11],"84":[3,1,30],"85":[4,1,65],"86":[4,1,51],"87":[4,1,83],"88":[7,1,13],"89":[4,1,58],"90":[4,1,5],"91":[2,4,9],"92":[2,4,12],"93":[1,4,75],"94":[4,1,7],"95":[4,1,16],"96":[4,1,13],"97":[4,1,5],"98":[5,1,46],"99":[4,1,29],"100":[5,1,32],"101":[4,1,6],"102":[1,4,23],"103":[1,4,24],"104":[4,1,1],"105":[1,4,14],"106":[1,4,6],"107":[4,1,7],"108":[1,4,7],"109":[4,1,18],"110":[3,1,27],"111":[3,1,10],"112":[3,1,19],"113":[4,1,19],"114":[4,1,51],"115":[4,1,39],"116":[3,1,10],"117":[4,1,3],"118":[3,1,30],"119":[3,1,16],"120":[3,1,26],"121":[5,1,46],"122":[3,1,6],"123":[3,1,32],"124":[3,1,9],"125":[3,1,2],"126":[3,1,12],"127":[3,1,21],"128":[5,1,9],"129":[1,5,14],"130":[5,1,9],"131":[3,1,13],"132":[3,1,23],"133":[3,1,35],"134":[3,1,6],"135":[4,1,15],"136":[5,1,55],"137":[4,1,6],"138":[4,1,15],"139":[3,1,8],"140":[3,1,3],"141":[1,3,30],"142":[1,3,30],"143":[3,1,45],"144":[1,3,26],"145":[3,1,7],"146":[3,1,37],"147":[3,1,37],"148":[6,1,50],"149":[2,6,41],"150":[2,6,8],"151":[5,1,12],"152":[3,1,38],"153":[5,1,44],"154":[3,1,39],"155":[6,1,43],"156":[4,1,31],"157":[3,1,42],"158":[2,3,20],"159":[3,1,1],"160":[4,3,5],"161":[4,3,7],"162":[5,1,7],"163":[1,5,6],"164":[1,5,14],"165":[1,5,1],"166":[1,5,5],"167":[1,5,4],"168":[1,5,18],"169":[1,5,4],"170":[1,5,6],"171":[1,5,1],"172":[1,5,3],"173":[1,1,5],"174":[1,1,13],"175":[1,1,5]},"averageFieldLength":[2.4886363636363624,2.5568181818181817,16],"storedFields":{"0":{"title":"关于 Corner Note","titles":[]},"1":{"title":"🍂 关于这个角落","titles":["关于 Corner Note"]},"2":{"title":"📖 我是谁","titles":["关于 Corner Note"]},"3":{"title":"📝 内容分类","titles":["关于 Corner Note"]},"4":{"title":"思维碎片","titles":["关于 Corner Note","📝 内容分类"]},"5":{"title":"灵感源泉","titles":["关于 Corner Note","📝 内容分类"]},"6":{"title":"迭代成长","titles":["关于 Corner Note","📝 内容分类"]},"7":{"title":"🌟 写作原则","titles":["关于 Corner Note"]},"8":{"title":"💫 联系我","titles":["关于 Corner Note"]},"9":{"title":"Runtime API Examples","titles":[]},"10":{"title":"Results","titles":["Runtime API Examples"]},"11":{"title":"Theme Data","titles":["Runtime API Examples","Results"]},"12":{"title":"Page Data","titles":["Runtime API Examples","Results"]},"13":{"title":"Page Frontmatter","titles":["Runtime API Examples","Results"]},"14":{"title":"More","titles":["Runtime API Examples"]},"15":{"title":"今日无事","titles":[]},"16":{"title":"创作实验","titles":[]},"17":{"title":"随笔角落","titles":[]},"18":{"title":"最新随笔","titles":["随笔角落"]},"19":{"title":"按标签浏览","titles":["随笔角落"]},"20":{"title":"九月小记","titles":[]},"21":{"title":"Markdown Extension Examples","titles":[]},"22":{"title":"Syntax Highlighting","titles":["Markdown Extension Examples"]},"23":{"title":"Custom Containers","titles":["Markdown Extension Examples"]},"24":{"title":"More","titles":["Markdown Extension Examples"]},"25":{"title":"软件测试核心概念","titles":[]},"26":{"title":"1. 什么是软件质量","titles":["软件测试核心概念"]},"27":{"title":"2. 什么是软件缺陷？它具有哪些危害，如何管理？","titles":["软件测试核心概念"]},"28":{"title":"软件缺陷的定义：","titles":["软件测试核心概念","2. 什么是软件缺陷？它具有哪些危害，如何管理？"]},"29":{"title":"缺陷管理流程：","titles":["软件测试核心概念","2. 什么是软件缺陷？它具有哪些危害，如何管理？"]},"30":{"title":"3. 什么是软件测试","titles":["软件测试核心概念"]},"31":{"title":"4. 测试的普遍性","titles":["软件测试核心概念"]},"32":{"title":"5. 软件测试的种类","titles":["软件测试核心概念"]},"33":{"title":"6. 软件测试的关键问题是什么？","titles":["软件测试核心概念"]},"34":{"title":"软件生命周期8阶段：","titles":["软件测试核心概念","6. 软件测试的关键问题是什么？"]},"35":{"title":"四个关键方面：","titles":["软件测试核心概念","6. 软件测试的关键问题是什么？"]},"36":{"title":"7. 软件测试的对象是什么","titles":["软件测试核心概念"]},"37":{"title":"8. 软件测试的停止准则有哪些","titles":["软件测试核心概念"]},"38":{"title":"9. 软件测试的周期性和并行性","titles":["软件测试核心概念"]},"39":{"title":"10. 软件测试的目的、意义和原则","titles":["软件测试核心概念"]},"40":{"title":"目的","titles":["软件测试核心概念","10. 软件测试的目的、意义和原则"]},"41":{"title":"意义","titles":["软件测试核心概念","10. 软件测试的目的、意义和原则"]},"42":{"title":"11. 软件测试的未来发展趋势","titles":["软件测试核心概念"]},"43":{"title":"12. 软件测试在软件工程中的位置","titles":["软件测试核心概念"]},"44":{"title":"13. 软件测试的模型","titles":["软件测试核心概念"]},"45":{"title":"V模型","titles":["软件测试核心概念","13. 软件测试的模型"]},"46":{"title":"W模型","titles":["软件测试核心概念","13. 软件测试的模型"]},"47":{"title":"X模型","titles":["软件测试核心概念","13. 软件测试的模型"]},"48":{"title":"14. 软件测试的过程（测试信息流程）","titles":["软件测试核心概念"]},"49":{"title":"15. 软件测试的研究进展","titles":["软件测试核心概念"]},"50":{"title":"16. 软件测试作为一种职业和科学","titles":["软件测试核心概念"]},"51":{"title":"17. 软件测试的工具分类","titles":["软件测试核心概念"]},"52":{"title":"18. 软件测试的管理框架","titles":["软件测试核心概念"]},"53":{"title":"时间维：全过程管理","titles":["软件测试核心概念","18. 软件测试的管理框架"]},"54":{"title":"空间维：全方位管理","titles":["软件测试核心概念","18. 软件测试的管理框架"]},"55":{"title":"组织维：人员管理","titles":["软件测试核心概念","18. 软件测试的管理框架"]},"56":{"title":"19. 软件测试的历史演进","titles":["软件测试核心概念"]},"57":{"title":"20. 软件测试的标准规范","titles":["软件测试核心概念"]},"58":{"title":"21. 解释软件的故障模型PIE","titles":["软件测试核心概念"]},"59":{"title":"PIE名称由来：","titles":["软件测试核心概念","21. 解释软件的故障模型PIE"]},"60":{"title":"三个层次：","titles":["软件测试核心概念","21. 解释软件的故障模型PIE"]},"61":{"title":"需求与商业模式创新","titles":[]},"62":{"title":"Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","titles":["需求与商业模式创新"]},"63":{"title":"多边平台商业模式：促进群体互动创造价值","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费"]},"64":{"title":"谷歌的商业模式：平台推广","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","多边平台商业模式：促进群体互动创造价值"]},"65":{"title":"当前的主流互联网产品基本都是多边平台商业模式","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","多边平台商业模式：促进群体互动创造价值"]},"66":{"title":"多边平台商业模式总结","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","多边平台商业模式：促进群体互动创造价值"]},"67":{"title":"免费的商业模式：其他方面补贴免费产品","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费"]},"68":{"title":"广告：一个多边平台商业模式","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","免费的商业模式：其他方面补贴免费产品"]},"69":{"title":"免费增值","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","免费的商业模式：其他方面补贴免费产品"]},"70":{"title":"保险：倒转的免费增值","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","免费的商业模式：其他方面补贴免费产品"]},"71":{"title":"免费增值模式总结","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","免费的商业模式：其他方面补贴免费产品"]},"72":{"title":"反转免费模式举例：Cookpad食谱网站","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","免费的商业模式：其他方面补贴免费产品"]},"73":{"title":"诱饵&amp;陷阱","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费","免费的商业模式：其他方面补贴免费产品"]},"74":{"title":"总结","titles":["需求与商业模式创新","Lesson 2 互联网+软件运营原理 商业模式类型-平台、免费"]},"75":{"title":"4.1 抽象：进程","titles":[]},"76":{"title":"进程 Process","titles":["4.1 抽象：进程"]},"77":{"title":"4.2 进程API","titles":[]},"78":{"title":"4.3 进程创建：更多细节","titles":[]},"79":{"title":"加载 load","titles":["4.3 进程创建：更多细节"]},"80":{"title":"分配内存","titles":["4.3 进程创建：更多细节"]},"81":{"title":"其他初始化任务","titles":["4.3 进程创建：更多细节"]},"82":{"title":"启动程序","titles":["4.3 进程创建：更多细节"]},"83":{"title":"4.4 进程状态","titles":[]},"84":{"title":"4.5 数据结构","titles":[]},"85":{"title":"5.1 fork()系统调用","titles":[]},"86":{"title":"5.2 wait()系统调用","titles":[]},"87":{"title":"5.3 exec()系统调用","titles":[]},"88":{"title":"6.1 基本技巧：受限直接执行 limited direct execution","titles":[]},"89":{"title":"6.2 问题1：受限制的操作","titles":[]},"90":{"title":"6.3 问题2：在进程之间切换","titles":[]},"91":{"title":"协同方式：等待系统调用","titles":["6.3 问题2：在进程之间切换"]},"92":{"title":"非协同方式：操作系统进行控制","titles":["6.3 问题2：在进程之间切换"]},"93":{"title":"保存和恢复上下文","titles":["6.3 问题2：在进程之间切换"]},"94":{"title":"7.3 先进先出 FIFO","titles":[]},"95":{"title":"7.4 最短任务有限 SJF","titles":[]},"96":{"title":"7.5 最短完成时间有限 STCF","titles":[]},"97":{"title":"7.6 新度量指标：响应时间","titles":[]},"98":{"title":"7.7 轮转 Round-Robin/RR调度","titles":[]},"99":{"title":"7.8 结合I/O","titles":[]},"100":{"title":"8.1 多级反馈队列 MLFQ：基本规则","titles":[]},"101":{"title":"8.2 尝试1：如何改变优先级","titles":[]},"102":{"title":"调整1","titles":["8.2 尝试1：如何改变优先级"]},"103":{"title":"问题","titles":["8.2 尝试1：如何改变优先级"]},"104":{"title":"8.3 尝试2：提升优先级","titles":[]},"105":{"title":"新规则","titles":["8.3 尝试2：提升优先级"]},"106":{"title":"问题","titles":["8.3 尝试2：提升优先级"]},"107":{"title":"8.4 尝试3：更好的计时方式","titles":[]},"108":{"title":"重写","titles":["8.4 尝试3：更好的计时方式"]},"109":{"title":"9.1 基本概念：彩票数表示份额","titles":[]},"110":{"title":"9.2 彩票机制","titles":[]},"111":{"title":"9.3 实现","titles":[]},"112":{"title":"9.6 为什么是不确定的","titles":[]},"113":{"title":"26.1 实例：线程创建","titles":[]},"114":{"title":"26.2 为什么更糟糕：共享数据","titles":[]},"115":{"title":"26.3 核心问题：不可控的调度","titles":[]},"116":{"title":"26.4 原子性愿望","titles":[]},"117":{"title":"26.5 还有一个问题：等待另一个线程","titles":[]},"118":{"title":"27.1 线程创建","titles":[]},"119":{"title":"27.2 线程完成","titles":[]},"120":{"title":"27.3 锁","titles":[]},"121":{"title":"27.4 条件变量 condition variable","titles":[]},"122":{"title":"27.5 编译和运行","titles":[]},"123":{"title":"28.1 锁的基本思想","titles":[]},"124":{"title":"28.2 Pthread锁","titles":[]},"125":{"title":"28.3 实现一个锁","titles":[]},"126":{"title":"28.4 评价锁","titles":[]},"127":{"title":"28.5 控制中断","titles":[]},"128":{"title":"28.6 测试并设置指令（原子交换）","titles":[]},"129":{"title":"尝试1","titles":["28.6 测试并设置指令（原子交换）"]},"130":{"title":"28.7 实现可用的自旋锁 spin lock","titles":[]},"131":{"title":"28.8 评价自旋锁","titles":[]},"132":{"title":"28.9 比较并交换","titles":[]},"133":{"title":"28.10 链接的加载和条件式存储指令","titles":[]},"134":{"title":"28.11 获取并增加","titles":[]},"135":{"title":"28.12 自旋过多：怎么办","titles":[]},"136":{"title":"28.13 简单方法：让出来吧，宝贝","titles":[]},"137":{"title":"28.14 使用队列：休眠替代自旋","titles":[]},"138":{"title":"28.15 不同操作系统，不同实现","titles":[]},"139":{"title":"28.16 两阶段锁","titles":[]},"140":{"title":"29.1 并发计数器","titles":[]},"141":{"title":"简单但无法扩展","titles":["29.1 并发计数器"]},"142":{"title":"可扩展的计数","titles":["29.1 并发计数器"]},"143":{"title":"29.2 并发链表","titles":[]},"144":{"title":"扩展列表","titles":["29.2 并发链表"]},"145":{"title":"29.3 并发队列","titles":[]},"146":{"title":"29.4 并发散列表","titles":[]},"147":{"title":"30.1 条件变量定义和程序","titles":[]},"148":{"title":"30.2 生产者/消费者（有界缓冲区）问题","titles":[]},"149":{"title":"单值缓冲区的生产者/消费者问题","titles":["30.2 生产者/消费者（有界缓冲区）问题"]},"150":{"title":"最终的生产者/消费者方案","titles":["30.2 生产者/消费者（有界缓冲区）问题"]},"151":{"title":"30.3 覆盖条件 covering condition","titles":[]},"152":{"title":"31.1 信号量的定义","titles":[]},"153":{"title":"31.2 二值信号量（锁）","titles":[]},"154":{"title":"31.3 信号量用作条件变量","titles":[]},"155":{"title":"31.4 生产者/消费者（有界缓冲区）问题","titles":[]},"156":{"title":"31.5 读者-写者锁","titles":[]},"157":{"title":"31.6 哲学家就餐问题","titles":[]},"158":{"title":"一种方案：破除依赖","titles":["31.6 哲学家就餐问题"]},"159":{"title":"32.2 非死锁缺陷","titles":[]},"160":{"title":"违反原子性缺陷（atomicity violation）","titles":["32.2 非死锁缺陷"]},"161":{"title":"违反顺序缺陷（order violation）","titles":["32.2 非死锁缺陷"]},"162":{"title":"32.3 死锁缺陷（deadlock）","titles":[]},"163":{"title":"为什么发生死锁","titles":["32.3 死锁缺陷（deadlock）"]},"164":{"title":"产生死锁的条件","titles":["32.3 死锁缺陷（deadlock）"]},"165":{"title":"预防","titles":["32.3 死锁缺陷（deadlock）"]},"166":{"title":"循环等待","titles":["32.3 死锁缺陷（deadlock）","预防"]},"167":{"title":"持有并等待","titles":["32.3 死锁缺陷（deadlock）","预防"]},"168":{"title":"非抢占","titles":["32.3 死锁缺陷（deadlock）","预防"]},"169":{"title":"互斥","titles":["32.3 死锁缺陷（deadlock）","预防"]},"170":{"title":"通过调度避免死锁","titles":["32.3 死锁缺陷（deadlock）"]},"171":{"title":"银行家算法","titles":["32.3 死锁缺陷（deadlock）","通过调度避免死锁"]},"172":{"title":"检查和恢复","titles":["32.3 死锁缺陷（deadlock）"]},"173":{"title":"学习笔记","titles":[]},"174":{"title":"最新笔记","titles":["学习笔记"]},"175":{"title":"按标签浏览","titles":["学习笔记"]}},"dirtCount":0,"index":[["机器学习",{"2":{"175":1}}],["机制",{"2":{"87":1}}],["笔记",{"2":{"174":1}}],["虚拟化",{"2":{"174":1}}],["阅读笔记",{"2":{"174":1}}],["殆已",{"2":{"173":1}}],["学习笔记",{"0":{"173":1},"1":{"174":1,"175":1}}],["学习和进步",{"2":{"6":1}}],["银行家算法",{"0":{"171":1}}],["包括不同线程在运行中对锁的需求情况",{"2":{"170":1}}],["了解全局的信息",{"2":{"170":1}}],["又同时抢锁失败",{"2":{"168":1}}],["又肝又氪",{"2":{"73":1}}],["活锁",{"2":{"168":1}}],["安排锁的获取并避免死锁",{"2":{"166":1}}],["安放被生活所惊扰的灵魂",{"2":{"1":1}}],["偏序",{"2":{"166":1}}],["预防",{"0":{"165":1},"1":{"166":1,"167":1,"168":1,"169":1}}],["环路上每个线程都额外持有一个资源",{"2":{"164":1}}],["循环等待",{"0":{"166":1},"2":{"164":1}}],["互斥",{"0":{"169":1},"2":{"164":1}}],["互联网产品的完整体验依赖于多方共同参与方能实现",{"2":{"65":1}}],["互联网+软件运营原理",{"0":{"62":1},"1":{"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1}}],["某些看起来没有关系的接口可能会导致死锁",{"2":{"163":1}}],["某些信息能够和模型中的信息建立映射关系",{"2":{"62":1}}],["隐藏实现细节的封装和模块化和锁不是很契合",{"2":{"163":1}}],["组件之间会有复杂的依赖",{"2":{"163":1}}],["组织维",{"0":{"55":1}}],["死锁避免",{"2":{"170":1}}],["死锁就不会产生",{"2":{"164":1}}],["死锁就产生了",{"2":{"162":1}}],["死锁缺陷",{"0":{"162":1},"1":{"163":1,"164":1,"165":1,"166":1,"167":1,"168":1,"169":1,"170":1,"171":1,"172":1}}],["却在等待锁l1释放时",{"2":{"162":1}}],["却能容纳无限思考",{"2":{"8":1}}],["违反顺序缺陷",{"0":{"161":1}}],["违反了多次内存访问中语气的可串行性",{"2":{"160":1}}],["违反原子性缺陷",{"0":{"160":1}}],["卡住等待另一个的情况",{"2":{"158":1}}],["卡在lock",{"2":{"123":1}}],["取餐叉的顺序不同",{"2":{"158":1}}],["取决于一个阈值s",{"2":{"142":1}}],["编译原理",{"2":{"175":1}}],["编译和运行",{"0":{"122":1}}],["编号最大的一个",{"2":{"158":1}}],["破除依赖",{"0":{"158":1}}],["破解",{"2":{"73":1}}],["右手边的叉子就调用right",{"2":{"157":1}}],["他们就调用left",{"2":{"157":1}}],["尽可能让更多哲学家同时吃东西",{"2":{"157":1}}],["围着一个圆桌",{"2":{"157":1}}],["哲学家有时要思考一会",{"2":{"157":1}}],["哲学家",{"2":{"157":1}}],["哲学家就餐问题",{"0":{"157":1},"1":{"158":1}}],["想要获取写锁的线程",{"2":{"156":1}}],["想要等待线程完成",{"2":{"119":1}}],["追踪目前有多少个读者在访问该数据结构",{"2":{"156":1}}],["追求完美",{"2":{"50":1}}],["中",{"2":{"156":1}}],["写者锁",{"0":{"156":1},"2":{"156":1}}],["写作原则",{"0":{"7":1}}],["读者很容易饿死写者",{"2":{"156":1}}],["读者首先要获取lock",{"2":{"156":1}}],["读者",{"0":{"156":1},"2":{"156":1}}],["减少锁的作用域",{"2":{"155":1}}],["避免死锁",{"2":{"155":1}}],["避免饿死",{"2":{"137":1}}],["希望父线程等待子线程运行",{"2":{"154":1}}],["希望它可以获得锁",{"2":{"139":1}}],["情况二",{"2":{"154":1}}],["情况一",{"2":{"154":1}}],["情况会更糟糕",{"2":{"135":1}}],["子线程会先调用sem",{"2":{"154":1}}],["子线程在父线程调用sem",{"2":{"154":1}}],["子线程运行的时候",{"2":{"154":1}}],["子线程调用sem",{"2":{"154":1}}],["子进程执行exec",{"2":{"87":1}}],["子进程调用execvp",{"2":{"87":1}}],["子进程总是先输出结果",{"2":{"86":1}}],["子进程虽然有自己的地址空间",{"2":{"85":1}}],["子进程不会从main",{"2":{"85":1}}],["父线程然后从sem",{"2":{"154":1}}],["父线程运行",{"2":{"154":1}}],["父线程创建了子线程",{"2":{"154":1}}],["父线程等待子线程执行完成",{"2":{"154":1}}],["父线程调用sem",{"2":{"154":2}}],["父进程调用wait",{"2":{"86":1}}],["父进程获得的返回值是新创建子进程的pid",{"2":{"85":1}}],["父进程",{"2":{"84":1}}],["程1",{"2":{"153":1}}],["程序正常运行",{"2":{"127":1}}],["程序可能在不同时间表现不同",{"2":{"103":1}}],["程序运行时",{"2":{"98":1}}],["程序必须执行特殊的陷阱",{"2":{"89":1}}],["程序",{"2":{"88":1,"89":1,"93":1}}],["程序计数器填充内核栈从陷阱返回",{"2":{"89":1}}],["程序计数器",{"2":{"85":1,"93":2}}],["程序寄存器pc",{"2":{"76":1}}],["程序编码",{"2":{"34":1}}],["线",{"2":{"153":1}}],["线程之间存在一个环路",{"2":{"164":1}}],["线程获得的资源不能被抢占",{"2":{"164":1}}],["线程有了资源",{"2":{"164":1}}],["线程有一个程序计数器pc",{"2":{"113":1}}],["线程对于需要的资源进行互斥的访问",{"2":{"164":1}}],["线程1执行结束时",{"2":{"153":1}}],["线程1",{"2":{"153":2}}],["线程0再次运行",{"2":{"153":1}}],["线程0在临界区中",{"2":{"153":1}}],["线程0现在可以自由进入临界区",{"2":{"153":1}}],["线程0",{"2":{"153":1}}],["线程将一个证书放入共享缓冲区loops次",{"2":{"148":1}}],["线程将获取该锁并进入临界区",{"2":{"120":1}}],["线程要睡眠时",{"2":{"147":1}}],["线程更多时",{"2":{"141":1}}],["线程可以把自己加入队列",{"2":{"147":1}}],["线程可以使用条件变量",{"2":{"147":1}}],["线程可以处于3中状态之一",{"2":{"136":1}}],["线程可以调用它主动放弃cpu",{"2":{"136":1}}],["线程尝试通过条件存储获取锁",{"2":{"133":1}}],["线程调用unlock",{"2":{"129":1}}],["线程完成",{"0":{"119":1}}],["线程创建",{"0":{"113":1,"118":1}}],["之前就运行结束",{"2":{"154":1}}],["之前",{"2":{"153":1}}],["之后操作系统再自动将这种货币兑换为正确的全局彩票",{"2":{"110":1}}],["之后",{"2":{"87":1,"112":1,"153":1}}],["把full",{"2":{"155":1}}],["把获取和释放互斥量的操作调整为紧挨着临界区",{"2":{"155":1}}],["把信号量减为−1",{"2":{"153":1}}],["把信号量的值减为0",{"2":{"153":1}}],["把一个值放在缓冲区",{"2":{"148":1}}],["二值信号量",{"0":{"153":1}}],["直接从sem",{"2":{"154":1}}],["直接增加信号量的值",{"2":{"152":1}}],["直到之后的一个post操作",{"2":{"152":1}}],["直到锁可用",{"2":{"130":1,"139":1}}],["直到其他线程唤醒它",{"2":{"121":1}}],["直到子进程执行完毕",{"2":{"86":1}}],["直到发生其他事件时才会准备运行",{"2":{"83":1}}],["信号量增加为0",{"2":{"154":1}}],["信号量用作条件变量",{"0":{"154":1}}],["信号量的初始值设置为0",{"2":{"154":1}}],["信号量的值不大于0",{"2":{"154":1}}],["信号量的值为负数时",{"2":{"152":1}}],["信号量的值大于等于1",{"2":{"152":1}}],["信号量的定义",{"0":{"152":1}}],["信号量是有一个整数值的对象",{"2":{"152":1}}],["信息技术服务的边界成本接近于零",{"2":{"62":1}}],["信息互联技术近四十年的高速发展",{"2":{"62":1}}],["代替上述代码中的pthread",{"2":{"151":1}}],["代码就会符合预期",{"2":{"150":1}}],["代码是唯一有趣的代码",{"2":{"133":1}}],["代码需要包括头文件pthread",{"2":{"122":1}}],["代码可以执行特权操作",{"2":{"89":1}}],["代码和数据的惰性加载如何工作",{"2":{"79":1}}],["代码免费完整开放",{"2":{"69":1}}],["覆盖条件",{"0":{"151":1}}],["总是使用while",{"2":{"150":1}}],["总结",{"0":{"74":1}}],["缓冲器已满",{"2":{"148":1}}],["缓冲器为空",{"2":{"148":1}}],["仅在计数为1",{"2":{"148":1}}],["仅在count为0时",{"2":{"148":1}}],["假设需要5个",{"2":{"157":1}}],["假设一个线程创建另一线程",{"2":{"154":1}}],["假设有两个线程的场景",{"2":{"153":1}}],["假设有一个或多个生产者线程和一个或多个消费者线程",{"2":{"148":1}}],["假设只有一个生产者和一个消费者",{"2":{"148":1}}],["假定哲学家4",{"2":{"158":1}}],["假定有5位",{"2":{"157":1}}],["假定在wait",{"2":{"147":1}}],["假定malloc",{"2":{"143":1}}],["假定操作系统提供原语yield",{"2":{"136":1}}],["消费者方案",{"0":{"150":1}}],["消费者线程等待fill",{"2":{"149":1}}],["消费者问题",{"0":{"149":1}}],["消费者取出数据",{"2":{"148":1}}],["消费者从缓冲区取走数据项",{"2":{"148":1}}],["消费者",{"0":{"148":1,"155":1},"1":{"149":1,"150":1}}],["生也有涯",{"2":{"173":1}}],["生产者也不会唤醒生产者",{"2":{"149":1}}],["生产者线程等待条件变量empty",{"2":{"149":1}}],["生产者把生成的数据项放入缓冲区",{"2":{"148":1}}],["生产者",{"0":{"148":1,"155":1},"1":{"149":1,"150":1},"2":{"148":1}}],["生活",{"2":{"19":1}}],["生活观察和偶然感悟",{"2":{"17":1}}],["生活富足的小资生活",{"2":{"1":1}}],["散列表使用之前实现的并发链表",{"2":{"146":1}}],["频繁地获取锁",{"2":{"144":1}}],["频繁放弃cpu的交互型工作",{"2":{"101":1}}],["很难比单锁的方法快",{"2":{"144":1}}],["释放锁",{"2":{"144":1,"156":1}}],["释放锁的开销巨大",{"2":{"144":1}}],["释放进程的内存将进程从进程列表中删除",{"2":{"89":1}}],["释放进程的内存给进程从进程列表中清楚",{"2":{"88":1}}],["遍历链表的时候",{"2":{"144":1}}],["替代之前整个链表一个锁",{"2":{"144":1}}],["替换为不同的运行程序",{"2":{"87":1}}],["过手锁",{"2":{"144":1}}],["扩展列表",{"0":{"144":1}}],["扩展性越强",{"2":{"142":1}}],["key",{"2":{"143":3,"146":6}}],["kernel",{"2":{"89":1}}],["懒惰计数器就越趋近于非扩展的计数器",{"2":{"142":1}}],["懒惰计数器通过多个局部计数器和一个全局计数器来实现一个逻辑计数器",{"2":{"142":1}}],["局部值会定期转移给全局计数器",{"2":{"142":1}}],["局限性",{"2":{"40":1}}],["访问这个局部计数器是通过对应的局部锁同步的",{"2":{"142":1}}],["那就增加它的局部计数器",{"2":{"142":1}}],["那么更有趣的情况就发生了",{"2":{"153":1}}],["那么高并发就没有什么意义",{"2":{"144":1}}],["那么线程只是简单地调用等待函数以便休眠",{"2":{"121":1}}],["那么尝试获取该锁的线程将不会从该调用返回",{"2":{"120":1}}],["那么就在开始的时候假设其是短工作",{"2":{"102":1}}],[">lists",{"2":{"146":3}}],[">lock",{"2":{"141":7,"143":5}}],[">next",{"2":{"143":2}}],[">key==key",{"2":{"143":1}}],[">key",{"2":{"143":1}}],[">head",{"2":{"143":4}}],[">value++",{"2":{"141":1}}],[">value",{"2":{"141":3}}],["简单但无法扩展",{"0":{"141":1}}],["简单方法",{"0":{"136":1}}],["计数器是最简单的一种数据结构",{"2":{"140":1}}],["常见的方法是在循环中自旋固定的次数",{"2":{"139":1}}],["两个线程可能一直重复这一序列",{"2":{"168":1}}],["两个内存访问的预期顺序被打破了",{"2":{"161":1}}],["两个锁",{"2":{"145":1}}],["两个关键指标",{"2":{"69":1}}],["两阶段的第一阶段先自旋一段时间",{"2":{"139":1}}],["两阶段锁",{"0":{"139":1}}],["唤醒父线程",{"2":{"154":1}}],["唤醒等待的线程",{"2":{"153":1}}],["唤醒等待队列中的一个线程",{"2":{"138":1}}],["唤醒其中一个",{"2":{"152":1}}],["唤醒所有的等待线程",{"2":{"151":1}}],["唤醒线程的代码运行在另外某个线程中",{"2":{"121":1}}],["休眠替代自旋",{"0":{"137":1}}],["饿死",{"2":{"136":1}}],["虽然比原来的浪费99个时间片的自旋方案要好",{"2":{"136":1}}],["完成临界区",{"2":{"136":1}}],["完成后",{"2":{"89":1}}],["完成后父进程将进行最后一次调用如wait",{"2":{"84":1}}],["另外某个线程",{"2":{"147":1}}],["另外一个线程运行",{"2":{"136":1}}],["另一个线程",{"2":{"153":1}}],["另一个负责队列尾",{"2":{"145":1}}],["另一个进程",{"2":{"95":1}}],["另一种常见的交互",{"2":{"117":1}}],["考虑在单cpu上运行两个线程",{"2":{"136":1}}],["考虑到如果所有工作同时到达",{"2":{"96":1}}],["yield",{"2":{"136":2}}],["持有并等待",{"0":{"167":1},"2":{"164":1}}],["持有锁的",{"2":{"136":1}}],["持续积累",{"2":{"7":1}}],["宝贝",{"0":{"136":1}}],["浪费cpu时间",{"2":{"135":1}}],["浪费掉整个时间片",{"2":{"135":1}}],["怎样避免自旋",{"2":{"135":1}}],["怎样进行测试",{"2":{"35":1}}],["怎么办",{"0":{"135":1}}],["返回",{"2":{"154":2}}],["返回该值",{"2":{"148":1}}],["返回0",{"2":{"133":1}}],["返回的字时不同的",{"2":{"85":1}}],["失败时",{"2":{"133":1}}],["条件存储返回1",{"2":{"133":1}}],["条件变量是一种简单可靠的方式",{"2":{"161":1}}],["条件变量是一个显式队列",{"2":{"147":1}}],["条件变量有两种相关操作",{"2":{"147":1}}],["条件变量定义和程序",{"0":{"147":1}}],["条件变量就很有用",{"2":{"121":1}}],["条件变量",{"0":{"121":1}}],["链接的加载指令和典型加载指令类似",{"2":{"133":1}}],["链接的加载load",{"2":{"133":1}}],["链接的加载和条件式存储指令",{"0":{"133":1}}],["链接时需要pthread库",{"2":{"122":1}}],["类似于用测试并设置那样",{"2":{"132":1}}],["答案是可以的",{"2":{"131":1}}],["能够互斥吗",{"2":{"131":1}}],["能够阻止其他进程进入直到本线程离开临界区",{"2":{"124":1}}],["否则调用立刻返回",{"2":{"138":1}}],["否则什么也不做",{"2":{"132":1}}],["否则",{"2":{"130":1}}],["否则将被慢慢移入低优先级队列",{"2":{"102":1}}],["自动化测试",{"2":{"174":1}}],["自动化功能测试工具",{"2":{"51":1}}],["自己睡眠",{"2":{"153":1}}],["自旋过多",{"0":{"135":1}}],["自旋锁性能不错",{"2":{"131":1}}],["自旋锁不提供任何公平性保证",{"2":{"131":1}}],["自旋锁一次只允许一个线程进入临界区",{"2":{"131":1}}],["自旋锁在单cpu上无法使用",{"2":{"130":1}}],["自旋等待浪费时间",{"2":{"129":1}}],["都有一个锁",{"2":{"146":1}}],["都是从内存中取出值存入一个寄存器",{"2":{"133":1}}],["都返回该内存地址的实际值",{"2":{"132":1}}],["都能进入临界区的场景",{"2":{"129":1}}],["都会举行一次彩票抽奖",{"2":{"109":1}}],["表明线程持有锁",{"2":{"129":1}}],["表示锁已经被占有",{"2":{"168":1}}],["表示锁未被持有",{"2":{"129":1}}],["表示有一个线程持有锁",{"2":{"123":1}}],["表示没有线程持有锁",{"2":{"123":1}}],["表示进程在创建时处于的装填",{"2":{"84":1}}],["后一支死循环",{"2":{"127":1}}],["缺点",{"2":{"127":1}}],["缺陷管理",{"2":{"54":1}}],["缺陷管理流程",{"0":{"29":1}}],["缺陷预测",{"2":{"29":1}}],["缺陷预防",{"2":{"29":1}}],["缺陷处理",{"2":{"29":1}}],["缺陷分类和跟踪",{"2":{"29":1}}],["缺陷记录和报告",{"2":{"29":1}}],["缺陷发现",{"2":{"29":1}}],["控制中断",{"0":{"127":1}}],["性能特别好",{"2":{"146":1}}],["性能更差",{"2":{"141":1}}],["性能开销相当大",{"2":{"131":1}}],["性能",{"2":{"126":1,"131":1}}],["性能测试工具",{"2":{"51":1}}],["公平性",{"2":{"126":1,"131":1}}],["提供互斥",{"2":{"126":1}}],["提升优先级",{"0":{"104":1},"1":{"105":1,"106":1}}],["提升产品竞争力",{"2":{"41":1}}],["里",{"2":{"123":1}}],["称为锁的持有者",{"2":{"123":1}}],["称为地址空间",{"2":{"76":1}}],["正在等待另外一个锁l2",{"2":{"162":1}}],["正确性",{"2":{"131":1}}],["正处于临界区",{"2":{"123":1}}],["正版影视",{"2":{"65":1}}],["才能吃到东西",{"2":{"157":1}}],["才能使用",{"2":{"123":1}}],["才从缓冲器获得数据",{"2":{"148":1}}],["才将数据放入缓冲器中",{"2":{"148":1}}],["才会成功",{"2":{"133":1}}],["才返回父进程",{"2":{"86":1}}],["增加互斥",{"2":{"155":1}}],["增加了链表操作的并发程度",{"2":{"144":1}}],["增加",{"2":{"122":1}}],["增值账户成本",{"2":{"71":1}}],["始终保持有锁",{"2":{"121":1}}],["像下面这样",{"2":{"121":1}}],["像这样的系统通常包括一个显式的yield系统调用",{"2":{"91":1}}],["应该持有这个锁",{"2":{"121":1}}],["应该检查失败并在获取锁或释放锁未成功时执行适当的操作",{"2":{"120":1}}],["应用模式",{"2":{"89":1,"93":1}}],["应用场景",{"2":{"31":1}}],["意味着持有该锁的线程通过解锁调用释放该锁",{"2":{"120":1}}],["意义",{"0":{"41":1}}],["意义和原则",{"0":{"39":1},"1":{"40":1,"41":1}}],["知道获得该锁",{"2":{"120":1}}],["知道所有任务完成",{"2":{"98":1}}],["锁是否能完成它的基本任务",{"2":{"126":1}}],["锁的状态就变成可用",{"2":{"123":1}}],["锁的持有者一旦调用unlock",{"2":{"123":1}}],["锁的基本思想",{"0":{"123":1}}],["锁就是一个变量",{"2":{"123":1}}],["锁",{"0":{"120":1,"153":1},"2":{"120":1}}],["必须仔细避免循环依赖导致的死锁",{"2":{"163":1}}],["必须通过同步机制来访问它",{"2":{"148":1}}],["必须重新获取锁",{"2":{"147":1}}],["必须另外有一个与此条件相关的锁",{"2":{"121":1}}],["必须调用函数pthread",{"2":{"119":1}}],["必定发生上下文切换",{"2":{"113":1}}],["被传入一个类型为void的参数",{"2":{"118":1}}],["被中断的进程",{"2":{"93":1}}],["该条件",{"2":{"147":1}}],["该调用不会返回",{"2":{"123":1}}],["该线程会获得锁",{"2":{"123":1}}],["该函数有4个参数",{"2":{"118":1}}],["该指令返回到发起调用的用户程序中",{"2":{"89":1}}],["该指令同时跳入内核并将特权级别提升到内核模式",{"2":{"89":1}}],["没有哲学家饿死",{"2":{"157":1}}],["没有等待",{"2":{"154":1}}],["没有被保持",{"2":{"133":1}}],["没有中间状态",{"2":{"116":1}}],["没有任何限制",{"2":{"88":1}}],["途径1",{"2":{"116":1}}],["原理很简单",{"2":{"144":1}}],["原子地",{"2":{"147":1}}],["原子交换",{"0":{"128":1},"1":{"129":1}}],["原子性愿望",{"0":{"116":1}}],["原来的进程称为父进程",{"2":{"85":1}}],["临界区是访问共享变量",{"2":{"115":1}}],["临时停止一个进程",{"2":{"95":1}}],["结束临界区时",{"2":{"129":1}}],["结束之后",{"2":{"127":1}}],["结果是不确定的",{"2":{"115":1}}],["结果取决于代码的时间执行",{"2":{"115":1}}],["结合i",{"0":{"99":1}}],["竞态条件",{"2":{"115":1}}],["给",{"2":{"115":1}}],["给counter加上一个数字",{"2":{"115":1}}],["放弃处理器",{"2":{"153":1}}],["放弃cpu",{"2":{"136":1}}],["放入",{"2":{"115":1}}],["放在最高优先级",{"2":{"102":1}}],["变量counter位于地址0x8049a1c",{"2":{"115":1}}],["变成运维一个促进多个客户群体相互交易的平台",{"2":{"74":1}}],["$0x1",{"2":{"115":1}}],["join",{"2":{"114":2,"119":2}}],["jsexport",{"2":{"22":1}}],["js三件套",{"2":{"1":1}}],["设想一个简单的例子",{"2":{"114":1}}],["设置得太低",{"2":{"106":1}}],["共享资源",{"2":{"115":1}}],["共享数据",{"0":{"114":1}}],["共同点",{"2":{"67":1}}],["区别在于线程上下文切换的时候地址空间保持不变",{"2":{"113":1}}],["单值缓冲区的生产者",{"0":{"149":1}}],["单cpu的情况下",{"2":{"131":1}}],["单步就能完成要做的事",{"2":{"116":1}}],["单个线程的状态与进程状态非常类似",{"2":{"113":1}}],["单元测试工具",{"2":{"51":1}}],["单元测试",{"2":{"32":1}}],["选择目前拥有最小进程值的进程",{"2":{"112":1}}],["和putforks",{"2":{"157":1}}],["和sem",{"2":{"152":1}}],["和signal",{"2":{"147":1}}],["和get",{"2":{"148":1}}],["和进程相比",{"2":{"113":1}}],["和票数值成反比",{"2":{"112":1}}],["和检索内容相关但可能付费的内容",{"2":{"64":1}}],["步长调度",{"2":{"112":1}}],["平均不公平度非常糟糕",{"2":{"111":1}}],["平台发展新趋势",{"2":{"71":1}}],["平台是最重要的资产",{"2":{"71":1}}],["平台的开发和维护",{"2":{"68":1}}],["平台升级",{"2":{"66":1}}],["平台管理",{"2":{"66":1}}],["平台收益流补贴",{"2":{"65":1}}],["平台推广",{"0":{"64":1}}],["平台通过促进不同群体之间的互动而创造价值",{"2":{"63":1}}],["平台对于其中某一客户群体的价值",{"2":{"63":1}}],["平台",{"0":{"62":1},"1":{"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1},"2":{"65":1}}],["建议将列表项按照票数递减排序",{"2":{"111":1}}],["建筑",{"2":{"31":1}}],["利用cpu周期",{"2":{"130":1}}],["利用这个结构与该线程交互",{"2":{"118":1}}],["利用通胀",{"2":{"110":1}}],["利用平台交易渠道降低交易成本",{"2":{"66":1}}],["请求其按自己的需求执行工作",{"2":{"110":1}}],["请注意",{"2":{"98":1}}],["允许死锁偶尔发生",{"2":{"172":1}}],["允许所有调用线程执行特权操作",{"2":{"127":1}}],["允许拥有一组彩票的用户以他们喜欢的某种货币",{"2":{"110":1}}],["允许其他进程",{"2":{"84":1}}],["越是应该拥有更多地赢得彩票的机会",{"2":{"109":1}}],["越是应该频繁运行的进程",{"2":{"109":1}}],["越短",{"2":{"98":1}}],["彩票通胀",{"2":{"110":1}}],["彩票转让",{"2":{"110":1}}],["彩票货币",{"2":{"110":1}}],["彩票机制",{"0":{"110":1}}],["彩票数代表了进程占有每个资源的份额",{"2":{"109":1}}],["彩票数表示份额",{"0":{"109":1}}],["彩票调度算法才能得到期望的结果",{"2":{"111":1}}],["彩票调度从概率上",{"2":{"109":1}}],["彩票调度",{"2":{"109":1}}],["比较并交换的基本思路是检测ptr指向的值是否和expected相等",{"2":{"132":1}}],["比较并交换",{"0":{"132":1}}],["比例份额调度程序基于一个简单的想法",{"2":{"109":1}}],["比如访问一个无关",{"2":{"103":1}}],["比如",{"2":{"93":1}}],["比如为程序的运行时栈",{"2":{"80":1}}],["比如git",{"2":{"1":1}}],["比如熟练使用一些工具",{"2":{"1":1}}],["比如vue3和react的前端开发经验",{"2":{"1":1}}],["移入低一级队列",{"2":{"108":1}}],["移入下一个队列",{"2":{"102":1}}],["长工作会饥饿",{"2":{"106":1}}],["首先需要一个共享缓冲区",{"2":{"148":1}}],["首先抢占下一个节点的锁",{"2":{"144":1}}],["首先",{"2":{"105":1,"133":1}}],["经过一段时间s",{"2":{"105":1}}],["尝试进入临界区",{"2":{"153":1}}],["尝试获取锁",{"2":{"123":1}}],["尝试3",{"0":{"107":1},"1":{"108":1}}],["尝试2",{"0":{"104":1},"1":{"105":1,"106":1}}],["尝试1",{"0":{"101":1,"129":1},"1":{"102":1,"103":1}}],["做的好时几乎可以独占cpu",{"2":{"103":1}}],["占用更多的cpu时间",{"2":{"103":1}}],["让代码不会产生循环等待",{"2":{"166":1}}],["让生产者放入数据",{"2":{"148":1}}],["让它们继续执行",{"2":{"147":1}}],["让它提供远超公平的资源",{"2":{"103":1}}],["让获取锁和释放锁只环绕插入代码的真正临界区",{"2":{"143":1}}],["让全局计数器加上局部计数器的值",{"2":{"142":1}}],["让出cpu",{"2":{"136":1}}],["让出线程本质上取消调度了它自己",{"2":{"136":1}}],["让出来吧",{"0":{"136":1}}],["让其他线程运行",{"2":{"136":1}}],["让调用者能够直到执行是否成功",{"2":{"132":1}}],["让交互型工作快速运行",{"2":{"102":1}}],["愚弄调度程序",{"2":{"103":1}}],["导致长工作永远无法得到cpu",{"2":{"103":1}}],["饥饿问题",{"2":{"103":1}}],["主要目标",{"2":{"102":1}}],["主页的想法",{"2":{"1":1}}],["则线程自动将标志值",{"2":{"133":1}}],["则很快会执行完毕",{"2":{"102":1}}],["则优先级不变",{"2":{"102":1}}],["则该进程可能会被阻塞几秒钟或更长时间",{"2":{"99":1}}],["降低其优先级",{"2":{"102":1}}],["规则5",{"2":{"105":1}}],["规则4",{"2":{"108":1}}],["规则4b",{"2":{"102":1}}],["规则4a",{"2":{"102":1}}],["规则3",{"2":{"102":1}}],["工作用完整个时间片后",{"2":{"102":1}}],["工作进入系统时",{"2":{"102":1}}],["工作负载",{"2":{"101":1}}],["既有运行时间很短",{"2":{"101":1}}],["去等待键盘输入",{"2":{"100":1}}],["交互型工作又得不到合适的cpu时间比例",{"2":{"106":1}}],["交互",{"2":{"99":1}}],["重新打开中断",{"2":{"127":1}}],["重写",{"0":{"108":1}}],["重写程序",{"2":{"103":1}}],["重叠",{"2":{"99":1}}],["重要成本结构",{"2":{"73":1}}],["重要研究时间点",{"2":{"49":1}}],["重要发现",{"2":{"28":1}}],["具体取决于驱动器当前的i",{"2":{"99":1}}],["调度彩票",{"2":{"110":1}}],["调度程序使用进程的步长及行程值来确定调度哪个进程",{"2":{"112":1}}],["调度程序的最终目标",{"2":{"109":1}}],["调度程序应该记录一个进程在某一层中消耗的总时间",{"2":{"107":1}}],["调度程序会正确对待它",{"2":{"105":1}}],["调度程序确保",{"2":{"99":1}}],["调度程序还必须在i",{"2":{"99":1}}],["调度程序需要在工作发起i",{"2":{"99":1}}],["调整1",{"0":{"102":1}}],["调用rwlock",{"2":{"156":1}}],["调用线程从函数返回并继续",{"2":{"153":1}}],["调用了sem",{"2":{"153":1}}],["调用sem",{"2":{"152":1,"153":2,"154":2}}],["调用signal",{"2":{"147":1}}],["调用时",{"2":{"147":1}}],["调用有一个参数",{"2":{"147":1}}],["调用wait",{"2":{"147":1}}],["调用futex",{"2":{"138":2}}],["调用者通过futex调用来睡眠或者唤醒",{"2":{"138":1}}],["调用lock",{"2":{"123":1,"129":1}}],["调用锁和释放锁时需要检查错误代码",{"2":{"120":1}}],["调用一个i",{"2":{"103":1}}],["调用系统调用陷入操作系统",{"2":{"89":1}}],["调用后",{"2":{"86":1}}],["任何时刻",{"2":{"100":1}}],["任何公平",{"2":{"98":1}}],["任务到达系统到首次运行的时间",{"2":{"97":1}}],["任务到达系统的时间",{"2":{"94":1}}],["任务完成时间",{"2":{"94":1}}],["带有合理时间片的rr会是很好的调度程序",{"2":{"98":1}}],["且与当前运行的作业相关的新状态被引入",{"2":{"98":1}}],["且是非抢占式",{"2":{"95":1}}],["切换到另一个工作会导致此状态被刷新",{"2":{"98":1}}],["使调用线程进入休眠状态",{"2":{"121":1}}],["使其足够长",{"2":{"98":1}}],["使用while循环总是对的",{"2":{"150":1}}],["使用广泛而且接口简单",{"2":{"140":1}}],["使用队列",{"0":{"137":1}}],["使用特殊的硬件指令",{"2":{"127":1}}],["使用特定测试用例设计方案作为判断基础",{"2":{"37":1}}],["使用锁之后增加的时间开销",{"2":{"126":1}}],["使用该进程的内核栈",{"2":{"93":1}}],["使用人工或自动的手段来运行或测定某个软件系统的过程",{"2":{"30":1}}],["突然上下文切换的成本将影响整体性能",{"2":{"98":1}}],["轮转运行a和b",{"2":{"100":1}}],["轮转",{"0":{"98":1}}],["响应时间却不重要的长时间计算密集型工作",{"2":{"101":1}}],["响应时间",{"0":{"97":1},"2":{"97":1}}],["谁的剩余时间最少",{"2":{"96":1}}],["每两位哲学家之间有一把餐叉",{"2":{"157":1}}],["每次打印出从共享缓冲区中提取的数据项",{"2":{"148":1}}],["每次运行不但会产生错误",{"2":{"114":1}}],["每次进程运行候",{"2":{"112":1}}],["每个餐叉一个",{"2":{"157":1}}],["每个哲学家的基本循环",{"2":{"157":1}}],["每个桶都是一个链表",{"2":{"146":1}}],["每个散列桶",{"2":{"146":1}}],["每个节点获取锁",{"2":{"144":1}}],["每个节点都有一个锁",{"2":{"144":1}}],["每个局部计数器有一个锁",{"2":{"142":1}}],["每个futex都关联一个特定的物理内存位置",{"2":{"138":1}}],["每个线程都可以调用它",{"2":{"143":1}}],["每个线程有自己的一组用于计算的寄存器",{"2":{"113":1}}],["每个线程有一个占",{"2":{"113":1}}],["每个线程类似于独立的进程",{"2":{"113":1}}],["每个都用于取指令和执行",{"2":{"113":1}}],["每个队列中可能会有多个工作",{"2":{"100":1}}],["每个队列有不同的优先级",{"2":{"100":1}}],["每隔一段时间",{"2":{"109":1}}],["每当新工作进入系统时",{"2":{"96":1}}],["每篇文章都用心打磨",{"2":{"7":1}}],["向sjf添加抢占",{"2":{"96":1}}],["抢占式",{"2":{"95":1}}],["抢占式调度程序vs非抢占式调度程序",{"2":{"95":1}}],["会将信号量重置为1",{"2":{"153":1}}],["会将每项工作做完",{"2":{"95":1}}],["会浪费n",{"2":{"135":1}}],["会让它的计数器",{"2":{"112":1}}],["会产生中断",{"2":{"99":1}}],["会从可执行程序中加载代码和静态数据",{"2":{"87":1}}],["先于子线程调用sem",{"2":{"154":1}}],["先用x86的mov",{"2":{"115":1}}],["先运行最短的任务",{"2":{"95":1}}],["先进先出",{"0":{"94":1}}],["护航效应",{"2":{"94":1}}],["周转时间只关系作业何时完成",{"2":{"98":1}}],["周转时间",{"2":{"94":1}}],["周期性",{"2":{"38":1}}],["明确地保存",{"2":{"93":1}}],["恢复",{"2":{"93":1}}],["恢复寄存器",{"2":{"93":1}}],["恢复到寄存器",{"2":{"93":1}}],["处理陷阱调用switch",{"2":{"93":1}}],["处理陷阱做系统调用的工作从陷阱返回",{"2":{"89":1}}],["转向用户模式跳到b的程序计数器",{"2":{"93":1}}],["转向内核模式跳到陷阱处理程序",{"2":{"93":1}}],["转发+话题",{"2":{"65":1}}],["启动时钟每隔x",{"2":{"93":1}}],["启动中断时钟",{"2":{"93":1}}],["启动",{"2":{"93":1}}],["启动程序",{"0":{"82":1}}],["至此上下文切换完成",{"2":{"93":1}}],["至少要使用包装的函数",{"2":{"120":1}}],["至少一个群体将得到免费的商品",{"2":{"67":1}}],["至少有一个关键的客户群体可以持续免费地享受服务",{"2":{"67":1}}],["即a应该在b之前执行",{"2":{"161":1}}],["即代码段本意是原子的",{"2":{"160":1}}],["即调用了sem",{"2":{"153":1}}],["即条件",{"2":{"147":1}}],["即时有大量的线程和很大的链表",{"2":{"144":1}}],["即时进程不协作",{"2":{"92":1}}],["即当一个线程在临界区",{"2":{"124":1}}],["即以原子方式执行",{"2":{"116":1}}],["即不需要切换当前使用的页表",{"2":{"113":1}}],["即在较高级队列中的工作",{"2":{"100":1}}],["即在小规模的时间内将cpu均匀分配到活动进程中",{"2":{"98":1}}],["即os",{"2":{"93":1}}],["即将执行的进程变成了当前运行的进程",{"2":{"93":1}}],["即将执行的进程",{"2":{"93":1}}],["是sem",{"2":{"152":1}}],["是线程安全的",{"2":{"143":1}}],["是否有竞争锁的线程会饿死",{"2":{"126":1}}],["是由线程创建函数初始化的",{"2":{"119":1}}],["是确保每个工作获得一定比例的cpu时间",{"2":{"109":1}}],["是另一进程",{"2":{"93":1}}],["是一个进程",{"2":{"93":1}}],["是平台低效的体现",{"2":{"71":1}}],["供即将运行的进程使用",{"2":{"93":1}}],["然而时间片太短",{"2":{"98":1}}],["然而现在鲜少有人使用它的网页版了",{"2":{"1":1}}],["然后再重复整个动作",{"2":{"168":1}}],["然后拿左手边",{"2":{"158":1}}],["然后增加reader变量",{"2":{"156":1}}],["然后当父线程有机会运行时",{"2":{"154":1}}],["然后睡眠等待",{"2":{"154":1}}],["然后线程1就可以获取锁",{"2":{"153":1}}],["然后等待",{"2":{"153":1}}],["然后只会在值小于0时等待",{"2":{"153":1}}],["然后把count设置为1表示缓冲区满了",{"2":{"148":1}}],["然后释放当前节点的锁",{"2":{"144":1}}],["然后将局部计数器置零",{"2":{"142":1}}],["然后使用futex睡眠",{"2":{"139":1}}],["然后设置标志为1",{"2":{"129":1}}],["然后",{"2":{"115":1}}],["然后切换到运行队列的下一个任务",{"2":{"98":1}}],["然后调度该工作",{"2":{"96":1}}],["然后是次短的任务",{"2":{"95":1}}],["然后恢复寄存器",{"2":{"93":1}}],["到它的内核栈",{"2":{"93":1}}],["时",{"2":{"138":1,"152":1,"153":1}}],["时没有其他线程持有锁",{"2":{"120":1}}],["时间片长度对于rr是至关重要的",{"2":{"98":1}}],["时间片长度必须是时钟中断周期的倍数",{"2":{"98":1}}],["时间维",{"0":{"53":1}}],["时钟处理程序",{"2":{"93":1}}],["时钟设备可以编程为每隔几毫秒产生一次中断",{"2":{"92":1}}],["时钟中断将寄存器",{"2":{"93":1}}],["时钟中断",{"2":{"92":1}}],["非抢占",{"0":{"168":1},"2":{"164":1}}],["非抢占式",{"2":{"95":1}}],["非死锁缺陷",{"0":{"159":1},"1":{"160":1,"161":1}}],["非协同方式",{"0":{"92":1}}],["非天猫",{"2":{"65":1}}],["将信号量从0增加到1",{"2":{"154":1}}],["将信号量减为",{"2":{"154":1}}],["将信号量的值增加到0",{"2":{"153":1}}],["将它恢复为1",{"2":{"153":1}}],["将它的初始值化为1",{"2":{"152":1}}],["将之前的测试并设置和等待队列结合",{"2":{"137":1}}],["将此段代码称为临界区",{"2":{"115":1}}],["将彩票分给自己的不同工作",{"2":{"110":1}}],["将进程结构",{"2":{"93":1}}],["将寄存器",{"2":{"93":1}}],["将寄存器保存到内核栈转向内核模式跳到陷阱处理程序",{"2":{"89":1}}],["将cpu的控制权转移给操作系统",{"2":{"91":1}}],["协同方式",{"0":{"91":1}}],["记录程序从哪里获取指令",{"2":{"113":1}}],["记录它的总体进展",{"2":{"112":1}}],["记录不平凡的思考",{"2":{"8":1}}],["记住以下位置",{"2":{"93":1}}],["记住系统调用处理程序的地址",{"2":{"89":1}}],["硬件同步原语",{"2":{"116":1}}],["硬件",{"2":{"89":2,"93":2}}],["告诉硬件在发生某些异常事件时要运行哪些代码",{"2":{"89":1}}],["内部通过一个writelock的信号量保证只有一个写者能获得锁进入临界区",{"2":{"156":1}}],["内运行一个工作",{"2":{"98":1}}],["内核寄存器被软件",{"2":{"93":1}}],["内核再进入切换代码调用时",{"2":{"93":1}}],["内核模式",{"2":{"89":2,"93":2}}],["内核通过在启动时设置陷阱表",{"2":{"89":1}}],["内容推广",{"2":{"65":1}}],["内容+弹幕",{"2":{"65":1}}],["内容分类",{"0":{"3":1},"1":{"4":1,"5":1,"6":1}}],["回到用户模式",{"2":{"89":1}}],["回归管理",{"2":{"54":1}}],["同步的计数器扩展性不好",{"2":{"141":1}}],["同时又在等待其他资源",{"2":{"164":1}}],["同时更新刚才链接的加载的地址的值",{"2":{"133":1}}],["同时将特权级别降低",{"2":{"89":1}}],["同样的场景下",{"2":{"135":1}}],["同样通过硬件指令",{"2":{"127":1}}],["同样很巧的是",{"2":{"1":1}}],["指向希望得到的返回值",{"2":{"119":1}}],["指令",{"2":{"89":1,"115":1,"133":1}}],["指产品早期中最认同产品并主动推广的群体",{"2":{"63":1}}],["要使用条件变量",{"2":{"121":1}}],["要么会让调用线程挂起",{"2":{"152":1}}],["要么立即返回",{"2":{"152":1}}],["要么是被占用的",{"2":{"123":1}}],["要么是可用的",{"2":{"123":1}}],["要么运行完成",{"2":{"116":1}}],["要么没有运行",{"2":{"116":1}}],["要执行系统调用",{"2":{"89":1}}],["要考虑广告费能否支撑起产品服务质量",{"2":{"68":1}}],["引入一种新的处理器模式",{"2":{"89":1}}],["受限制的操作",{"0":{"89":1}}],["受限直接执行",{"0":{"88":1},"2":{"87":1}}],["方法是获取全局锁",{"2":{"142":1}}],["方法",{"2":{"88":1}}],["清楚标指",{"2":{"129":1}}],["清楚寄存器执行call",{"2":{"88":1}}],["清晨五点的城市",{"2":{"18":1}}],["基于yield的方法十分有效",{"2":{"136":1}}],["基于多边平台的免费商品",{"2":{"67":1}}],["基本思想",{"2":{"142":1}}],["基本概念",{"0":{"109":1}}],["基本规则",{"0":{"100":1}}],["基本技巧",{"0":{"88":1}}],["几乎就像p3",{"2":{"87":1}}],["堆栈及其他内存空间也会被重新初始化",{"2":{"87":1}}],["实例",{"0":{"113":1}}],["实现了一个更高性能的锁",{"2":{"137":1}}],["实现其他并发架构",{"2":{"133":1}}],["实现可用的自旋锁",{"0":{"130":1}}],["实现一个锁",{"0":{"125":1}}],["实现",{"0":{"111":1}}],["实际上",{"2":{"87":1}}],["实质上改变了人类社会的组织形式",{"2":{"62":1}}],["因未能覆盖所有需要唤醒线程的场景",{"2":{"151":1}}],["因为最后一个哲学家会尝试先拿右手边的餐叉",{"2":{"158":1}}],["因为等待线程在等待某些条件发生变化",{"2":{"154":1}}],["因为没有等待线程",{"2":{"153":1}}],["因为值是0",{"2":{"153":1}}],["因为信号量的初始值能够决定其行为",{"2":{"152":1}}],["因为不必要地唤醒了其他许多等待的线程",{"2":{"151":1}}],["因为有界缓冲区是共享资源",{"2":{"148":1}}],["因为入队列只访问tail锁",{"2":{"145":1}}],["因为每个cpu有自己的局部计数器",{"2":{"142":1}}],["因为一个自旋的线程永远不会放弃cpu",{"2":{"130":1}}],["因为我们可能用不同的锁来保护不同的变量",{"2":{"124":1}}],["因为它被用来提供线程之间的互斥",{"2":{"124":1}}],["因为锁被另一线程持有",{"2":{"123":1}}],["因为pthread",{"2":{"119":1}}],["因为函数可以返回任何东西",{"2":{"119":1}}],["因为当前正在运行的作业在i",{"2":{"99":1}}],["因为学这个",{"2":{"1":1}}],["因此名为活锁",{"2":{"168":1}}],["因此0为初值",{"2":{"154":1}}],["因此都在队列中等待被唤醒",{"2":{"152":1}}],["因此浪费很大",{"2":{"136":1}}],["因此表明锁",{"2":{"133":1}}],["因此等待其他线程发出信号",{"2":{"121":1}}],["因此会让它保持高优先级",{"2":{"100":1}}],["因此具有同样的优先级",{"2":{"100":1}}],["因此",{"2":{"98":1,"99":1,"113":1,"136":1,"150":1}}],["因此增加wait",{"2":{"86":1}}],["延迟自己的执行",{"2":{"86":1}}],["私有内存",{"2":{"85":1}}],["私密性和文学性更强的博客有所不同",{"2":{"1":1}}],["函数会尝试获得锁",{"2":{"168":1}}],["函数之中会有临界区",{"2":{"148":1}}],["函数把缓冲区清空后",{"2":{"148":1}}],["函数改变了传入参数的值",{"2":{"119":1}}],["函数名start",{"2":{"118":1}}],["函数指针",{"2":{"118":1}}],["函数开始执行",{"2":{"85":1}}],["函数参数和返回地址",{"2":{"80":1}}],["看起来有两个完全一样的p1程序在运行",{"2":{"85":1}}],["系统一直在运行这段代码",{"2":{"168":1}}],["系统中的每个工作都有自己的步长",{"2":{"112":1}}],["系统因此得到更好的利用",{"2":{"99":1}}],["系统设计这需要权衡时间片的长度",{"2":{"98":1}}],["系统就可以执行任何需要的特权操作",{"2":{"89":1}}],["系统调用能够让运行态变成就绪态",{"2":{"136":1}}],["系统调用处理程序",{"2":{"93":1}}],["系统调用可以让子进程执行与父进程不同的程序",{"2":{"87":1}}],["系统调用返回",{"2":{"85":1}}],["系统调用中返回",{"2":{"85":1}}],["系统调用fork",{"2":{"85":1}}],["系统调用",{"0":{"85":1,"86":1,"87":1}}],["系统测试",{"2":{"32":1}}],["检查到死锁时再采取行动",{"2":{"172":1}}],["检查和恢复",{"0":{"172":1}}],["检查标志是否为1",{"2":{"129":1}}],["检查进程的返回代码并查看刚刚完成的进程是否成功执行",{"2":{"84":1}}],["检查系统是否满足需求要求",{"2":{"40":1}}],["up",{"2":{"136":1}}],["unlock",{"2":{"120":1,"121":2,"136":1,"141":3,"143":2,"149":2}}],["unistd",{"2":{"86":1,"87":1}}],["unix系统中",{"2":{"84":1}}],["user",{"2":{"89":1}}],["used",{"2":{"9":1}}],["usedata",{"2":{"9":3}}],["usistd",{"2":{"85":1}}],["usage",{"2":{"9":1}}],["已退出但尚未清理的罪状状态",{"2":{"84":1}}],["已被放弃",{"2":{"71":1}}],["初始化陷阱表",{"2":{"89":1,"93":1}}],["初始状态",{"2":{"84":1}}],["初始产品补贴与后续产品的成本",{"2":{"73":1}}],["还需要操作系统支持",{"2":{"135":1}}],["还会让调用者睡眠时释放锁",{"2":{"121":1}}],["还有锁",{"2":{"142":1}}],["还有一个问题",{"0":{"117":1}}],["还有其他一些进程可以处于的状态",{"2":{"84":1}}],["还可能有其他控制",{"2":{"77":1}}],["上下文切换的成本是实实在在的",{"2":{"136":1}}],["上下文切换的成本不仅仅来自于保存和恢复少量寄存器的操作系统操作",{"2":{"98":1}}],["上下文切换",{"2":{"84":1,"93":1}}],["上瘾",{"2":{"73":1}}],["通过调度避免死锁",{"0":{"170":1},"1":{"171":1}}],["通过强大的硬件指令",{"2":{"169":1}}],["通过强制顺序来修复这种缺陷",{"2":{"161":1}}],["通过原子地抢锁来避免",{"2":{"167":1}}],["通过第三个参数",{"2":{"152":1}}],["通过在该条件上发信号",{"2":{"147":1}}],["通过在进入临界区之前关闭中断",{"2":{"127":1}}],["通过队列来控制谁会获得锁",{"2":{"137":1}}],["通过",{"2":{"120":1}}],["通过转让",{"2":{"110":1}}],["通过不断定时地抽取彩票",{"2":{"109":1}}],["通过这种方式",{"2":{"100":1,"102":1}}],["通过将每个cpu突发作为一项工作",{"2":{"99":1}}],["通过切换栈",{"2":{"93":1}}],["通过exit",{"2":{"89":1}}],["通过回复这些寄存器",{"2":{"84":1}}],["通过对不同客户群体的收益流进行调整",{"2":{"74":1}}],["数据结构",{"0":{"84":1}}],["数字产品与服务的复制传播成本接近于0",{"2":{"67":1}}],["阻塞",{"2":{"83":1}}],["运行a",{"2":{"100":1}}],["运行进程的用户寄存器由硬件隐式保存",{"2":{"93":1}}],["运行main",{"2":{"89":1}}],["运行",{"2":{"83":1,"89":2,"93":1,"136":1}}],["运营利润",{"2":{"71":1}}],["例程+",{"2":{"93":1}}],["例程",{"2":{"82":1}}],["例如mips架构中",{"2":{"133":1}}],["例如",{"2":{"89":1,"162":1}}],["例如初始化变量",{"2":{"79":1}}],["例如暂停进程然后恢复",{"2":{"77":1}}],["跳转到main",{"2":{"82":1}}],["相应地",{"2":{"149":1}}],["相比之下彩票调度的优势",{"2":{"112":1}}],["相反",{"2":{"100":1}}],["相关的任务",{"2":{"81":1}}],["相信时间的力量",{"2":{"7":1}}],["输出结果变得确定了",{"2":{"86":1}}],["输出",{"2":{"81":1}}],["与其他高优先级工作分享cpu",{"2":{"105":1}}],["与用户模式不同的内核模式",{"2":{"89":1}}],["与输入",{"2":{"81":1}}],["与增值用户转化率",{"2":{"69":1}}],["用二值信号量来增加锁",{"2":{"155":1}}],["用pthread",{"2":{"151":1}}],["用一个队列来保存等待锁的线程",{"2":{"137":1}}],["用一个变量来标志锁是否被某些线程占用",{"2":{"129":1}}],["用一些卑鄙的手段欺骗调度程序",{"2":{"103":1}}],["用于指定要等待的线程",{"2":{"119":1}}],["用于创建新进程",{"2":{"85":1}}],["用于显式请求的动态分配数据",{"2":{"80":1}}],["用户模式",{"2":{"89":1}}],["用户数量增值用户比重增值服务价格增长率顾客流失率",{"2":{"71":1}}],["用户付费给商户",{"2":{"64":1}}],["用户可见的外部错误",{"2":{"60":1}}],["也达到了预期效果",{"2":{"154":1}}],["也叫做锁耦合",{"2":{"144":1}}],["也叫做原子交换",{"2":{"128":1}}],["也有一个事先建好的内核队列",{"2":{"138":1}}],["也有需要很多cpu时间",{"2":{"101":1}}],["也会将控制转移给操作系统",{"2":{"91":1}}],["也奉陪内存",{"2":{"80":1}}],["也许我对cs行业唯一感谢和庆幸的是",{"2":{"1":1}}],["hash",{"2":{"146":8}}],["hand",{"2":{"144":2}}],["h才能编译",{"2":{"122":1}}],["h",{"2":{"114":1,"146":6}}],["hello",{"2":{"85":3,"86":3,"87":3}}],["heap",{"2":{"80":1}}],["h>",{"2":{"85":3,"86":4,"87":5,"114":2,"118":1,"152":1}}],["highlighted",{"2":{"22":2}}],["highlighting",{"0":{"22":1},"2":{"22":2}}],["并没有等待某些条件满足",{"2":{"152":1}}],["并让调用线程休眠",{"2":{"147":1}}],["并发散列表",{"0":{"146":1}}],["并发队列",{"0":{"145":1}}],["并发链表",{"0":{"143":1},"1":{"144":1}}],["并发计数器",{"0":{"140":1},"1":{"141":1,"142":1}}],["并将ptr指的值更新为value",{"2":{"133":1}}],["并将它们放在内存中单某处",{"2":{"79":1}}],["并在锁和解锁被调用时按照需要工作",{"2":{"120":1}}],["并且并发度高",{"2":{"157":1}}],["并且等待它结束",{"2":{"154":1}}],["并且让该值自增一",{"2":{"134":1}}],["并且不会更新值",{"2":{"133":1}}],["并且返回一个void类型的值",{"2":{"118":1}}],["并且在运行后将该进程的行程值增加一个步长",{"2":{"112":1}}],["并且都从fork",{"2":{"85":1}}],["并赋予最高优先级",{"2":{"102":1}}],["并恢复",{"2":{"95":1}}],["并切换内核栈",{"2":{"93":1}}],["并为即将执行的进程恢复一些寄存器的值",{"2":{"93":1}}],["并用它覆写自己的代码段以及静态数据",{"2":{"87":1}}],["并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构",{"2":{"84":1}}],["并引导其重复购买",{"2":{"67":1}}],["加载到进程的地址空间中",{"2":{"79":1}}],["加载到内存中",{"2":{"79":1}}],["加载",{"0":{"79":1}}],["加工",{"2":{"74":1}}],["更灵活的接口",{"2":{"168":1}}],["更多并发不一定更快",{"2":{"144":1}}],["更多细节",{"0":{"78":1},"1":{"79":1,"80":1,"81":1,"82":1}}],["更改为1",{"2":{"133":1}}],["更新ptr所指的值为新值",{"2":{"132":1}}],["更好的计时方式",{"0":{"107":1},"1":{"108":1}}],["更一般地说",{"2":{"98":1}}],["更正缺陷或修复问题的费用呈几何级数增长",{"2":{"28":1}}],["获取锁时提供一个全序",{"2":{"166":1}}],["获取读锁时",{"2":{"156":1}}],["获取并增加fetch",{"2":{"134":1}}],["获取并增加",{"0":{"134":1}}],["获取该锁",{"2":{"123":1}}],["获得写锁",{"2":{"156":1}}],["获得这种份额比例",{"2":{"109":1}}],["获得有关进程的状态信息",{"2":{"77":1}}],["获客成本",{"2":{"71":1}}],["状态",{"2":{"77":1}}],["除了这些计数器",{"2":{"142":1}}],["除了运行",{"2":{"84":1}}],["除了杀死或等待进程外",{"2":{"77":1}}],["除非仅处理有限种情况",{"2":{"40":1}}],["等待循环被打破了",{"2":{"158":1}}],["等待缓冲区变空",{"2":{"148":1}}],["等待被中断的",{"2":{"136":1}}],["等待线程在while循环中重新检查条件",{"2":{"121":1}}],["等待调用除了使调用线程进入睡眠状态外",{"2":{"121":1}}],["等待调用将锁作为其第二个参数",{"2":{"121":1}}],["等待另一个线程",{"0":{"117":1}}],["等待系统调用",{"0":{"91":1}}],["等待",{"2":{"77":1,"147":1}}],["强制销毁进程的接口",{"2":{"77":1}}],["销毁",{"2":{"77":1}}],["销售",{"2":{"74":1}}],["操作系统运行并将发出i",{"2":{"99":1}}],["操作系统运行程序必须做的第一件事是将代码和所有静态数据",{"2":{"79":1}}],["操作系统决定从a切换到b",{"2":{"93":1}}],["操作系统会执行一些底层汇编代码",{"2":{"93":1}}],["操作系统就可以确保最后执行从陷阱返回指令时",{"2":{"93":1}}],["操作系统为当前正在执行的进程保留一些寄存器的值",{"2":{"93":1}}],["操作系统为正在运行的程序提供的抽象",{"2":{"76":1}}],["操作系统也必须启动时钟",{"2":{"92":1}}],["操作系统必须通知硬件哪些代码在发生时钟中断时运行",{"2":{"92":1}}],["操作系统必须包含一些创建新进程的方法",{"2":{"77":1}}],["操作系统重新获得cpu的控制权",{"2":{"92":1}}],["操作系统中预先配置的中断处理程序会运行",{"2":{"92":1}}],["操作系统可以做什么来确保流氓进程不会占用机器",{"2":{"92":1}}],["操作系统可能会终止进程",{"2":{"89":1}}],["操作系统如何获得cpu的控制权",{"2":{"92":1}}],["操作系统如何重新获得cpu的控制权",{"2":{"90":1}}],["操作系统进行控制",{"0":{"92":1}}],["操作系统调用一个特殊的从陷阱返回的指令",{"2":{"89":1}}],["操作系统或内核就以这种模式运行",{"2":{"89":1}}],["操作系统",{"2":{"88":1,"89":2,"93":2}}],["操作系统他跟踪进程的一些重要信息",{"2":{"84":1}}],["操作系统选择不在此时运行",{"2":{"83":1}}],["操作系统分配内存并提供给进程",{"2":{"80":1}}],["操作系统从磁盘读取这些字节",{"2":{"79":1}}],["帧指针fp",{"2":{"76":1}}],["栈指针sp",{"2":{"76":1}}],["特殊的寄存器",{"2":{"76":1}}],["寄存器的值加",{"2":{"115":1}}],["寄存器上下文将保存其寄存器的内容",{"2":{"84":1}}],["寄存器",{"2":{"76":1,"85":1}}],["进入临界区",{"2":{"123":2}}],["进入b",{"2":{"93":1}}],["进程重新运行",{"2":{"136":1}}],["进程值pass值增加步长",{"2":{"112":1}}],["进程之间相互不信任",{"2":{"110":1}}],["进程不会饿死",{"2":{"105":1}}],["进程不能发出i",{"2":{"89":1}}],["进程在时间片用完前",{"2":{"103":1}}],["进程b",{"2":{"93":1}}],["进程a",{"2":{"93":1}}],["进程api",{"0":{"77":1}}],["进程状态",{"0":{"83":1}}],["进程创建",{"0":{"78":1},"1":{"79":1,"80":1,"81":1,"82":1}}],["进程可访问的内存",{"2":{"76":1}}],["进程的机器状态",{"2":{"76":1}}],["进程",{"0":{"75":1,"76":1},"1":{"76":1}}],["进而补贴产品和服务",{"2":{"68":1}}],["抽象",{"0":{"75":1},"1":{"76":1}}],["来等待一个条件变成真",{"2":{"147":1}}],["来提供互斥进入临界区的函数",{"2":{"120":1}}],["来保存通用寄存器",{"2":{"93":1}}],["来运行字符技术程序wc",{"2":{"87":1}}],["来加速平台运转",{"2":{"74":1}}],["来了",{"2":{"1":1}}],["补贴最重要的客户群体",{"2":{"74":1}}],["补贴正确的客户群是定价决策的关键",{"2":{"66":1}}],["充分利用人人互联成本趋零这一it技术的带来的生产力优势",{"2":{"74":1}}],["挂羊头卖狗肉",{"2":{"73":1}}],["有界缓冲区",{"0":{"148":1,"155":1},"1":{"149":1,"150":1}}],["有4个局部计数器和1个全局计数器",{"2":{"142":1}}],["有了比较并交换指令",{"2":{"132":1}}],["有时又要就餐",{"2":{"157":1}}],["有时称为调度量子",{"2":{"98":1}}],["有时候人们会将存储关于进程的信息的个体结构成为进程控制块",{"2":{"84":1}}],["有两种类型的寄存器保存",{"2":{"93":1}}],["有毒",{"2":{"73":1}}],["有的下定决心通过考试一战成硕",{"2":{"1":1}}],["盖楼",{"2":{"73":1}}],["各类社交裂变式促销",{"2":{"73":1}}],["新的问题",{"2":{"168":1}}],["新规则",{"0":{"105":1}}],["新度量指标",{"0":{"97":1}}],["新创建的进程称为子进程",{"2":{"85":1}}],["新套餐体验+自动续费",{"2":{"73":1}}],["新时代",{"2":{"73":1}}],["支撑",{"2":{"73":1}}],["资源",{"2":{"73":1}}],["资本主义的基石",{"2":{"70":1}}],["专利护城河",{"2":{"73":1}}],["核心概念",{"2":{"174":1}}],["核心问题",{"0":{"115":1}}],["核心业务",{"2":{"73":1}}],["核心资源",{"2":{"71":1}}],["核心资源是平台",{"2":{"66":1}}],["吉列剃须刀",{"2":{"73":1}}],["套餐收费",{"2":{"73":1}}],["手机免费",{"2":{"73":1}}],["合约机",{"2":{"73":1}}],["推进线下运营与会员转化",{"2":{"72":1}}],["丰富企业服务与媒体功能",{"2":{"72":1}}],["反转免费模式举例",{"0":{"72":1}}],["反面例子",{"2":{"71":1}}],["精选节目",{"2":{"71":1}}],["+",{"2":{"71":1,"73":1,"93":1}}],["+社区管理",{"2":{"65":1}}],["涨价",{"2":{"71":1}}],["爱奇艺盈利",{"2":{"71":1}}],["庆余年与腾讯vvip",{"2":{"71":1}}],["为单处理器系统开发的",{"2":{"127":1}}],["为什么发生死锁",{"0":{"163":1}}],["为什么更糟糕",{"0":{"114":1}}],["为什么是不确定的",{"0":{"112":1}}],["为了保持全局计数器更新",{"2":{"142":1}}],["为了保存当前正在运行的进程的上下文",{"2":{"93":1}}],["为了加速服务端的执行",{"2":{"110":1}}],["为mlfq的每层队列提供更完善的cpu计时方式",{"2":{"107":1}}],["为程序的堆",{"2":{"80":1}}],["为免费增值提供空间",{"2":{"71":1}}],["为产品从0到1阶段提供关键支持",{"2":{"63":1}}],["差异化的产品与服务",{"2":{"71":1}}],["高水平",{"2":{"71":1}}],["固定成本",{"2":{"71":1}}],["服务端执行结束后会将这部分彩票归还给客户端",{"2":{"110":1}}],["服务成本",{"2":{"71":2}}],["服务实现",{"2":{"66":1}}],["客户端可以将自己的彩票转让给服务端",{"2":{"110":1}}],["客户端进程向服务端发送消息",{"2":{"110":1}}],["客户关系自动且低成本",{"2":{"71":1}}],["客户群体间交易",{"2":{"66":1}}],["客户群体相互依存",{"2":{"66":1}}],["产生死锁的条件",{"0":{"164":1}}],["产生中断时",{"2":{"92":1}}],["产生三部分成本",{"2":{"71":1}}],["产品的思路",{"2":{"73":1}}],["产品与后续产品之间要有紧密连接",{"2":{"73":1}}],["产品法律上拥有者联系的保证",{"2":{"69":1}}],["产品运营",{"2":{"65":1}}],["风险分摊与应对",{"2":{"70":1}}],["倒转的免费增值",{"0":{"70":1}}],["保证没有死锁",{"2":{"157":1}}],["保存到进程结构",{"2":{"93":1}}],["保存到内核栈",{"2":{"93":1}}],["保存和恢复上下文",{"0":{"93":1}}],["保险",{"0":{"70":1}}],["保障软件质量",{"2":{"41":1}}],["无等待数据结构的思想",{"2":{"169":1}}],["无论中间主动放弃了多少次",{"2":{"108":1}}],["无限制服务支持",{"2":{"69":1}}],["无法独立",{"2":{"66":1}}],["年费换取最新源码使用权",{"2":{"69":1}}],["跨平台",{"2":{"69":1}}],["跨行业应用",{"2":{"31":1}}],["印象笔记",{"2":{"69":1}}],["百度网盘",{"2":{"69":1}}],["及其他额外功能",{"2":{"69":1}}],["少量年费换无限量上传次数与空间",{"2":{"69":1}}],["少量用户为增值服务付费",{"2":{"69":1}}],["照片分享网站flickr",{"2":{"69":1}}],["案例",{"2":{"69":2}}],["低边界成本",{"2":{"69":1}}],["收入",{"2":{"71":2}}],["收入来源三个重要公式",{"2":{"71":1}}],["收入形式",{"2":{"69":1}}],["收视体验",{"2":{"65":1}}],["以有涯逐无涯",{"2":{"173":1}}],["以免产生竞态条件",{"2":{"148":1}}],["以免费或很便宜的初始价格吸引客户",{"2":{"67":1}}],["以某种方式消费",{"2":{"148":1}}],["以防某个线程要读取该值",{"2":{"142":1}}],["以确保它们具有正确的值",{"2":{"120":1}}],["以确定接下来应该运行哪个进程",{"2":{"109":1}}],["以及一个消费者",{"2":{"148":1}}],["以及所有彩票的总数",{"2":{"111":1}}],["以及当前正在运行的进程的内核栈指针",{"2":{"93":1}}],["以及可能的获客与维系成本",{"2":{"68":1}}],["以便摊销上下文切换成本",{"2":{"98":1}}],["以便系统可以运行其他进程",{"2":{"91":1}}],["以便它可以在进程之间切换",{"2":{"90":1}}],["以前的p3",{"2":{"87":1}}],["以等待子进程的完成",{"2":{"84":1}}],["以扩展用户总数与客户群体类别",{"2":{"74":1}}],["流量红利已见底",{"2":{"68":1}}],["吞噬广告费的产品太多",{"2":{"68":1}}],["好的产品和服务以及高流量会吸引广告商",{"2":{"68":1}}],["好像已经被排除在社会时钟之外的的生活令我辗转反侧",{"2":{"1":1}}],["关闭中断导致终端丢失",{"2":{"127":1}}],["关键的挑战就是如何实现getforks",{"2":{"157":1}}],["关键区别来自条件式存储",{"2":{"133":1}}],["关键问题",{"2":{"90":1,"135":1}}],["关键业务",{"2":{"68":1,"71":1}}],["关注后续产品交付",{"2":{"73":1}}],["关注免费用户服务成本",{"2":{"69":1}}],["关于孤独的再思考",{"2":{"18":1}}],["关于这个角落",{"0":{"1":1}}],["关于",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1}}],["瑞典的东方卫报",{"2":{"68":1}}],["陷阱",{"0":{"73":1},"2":{"67":1,"73":1}}],["诱饵",{"0":{"73":1},"2":{"67":1,"73":1}}],["广告",{"0":{"68":1}}],["广告模式",{"2":{"67":1}}],["广告商",{"2":{"64":1}}],["海量用户下边界成本也趋向于0",{"2":{"67":1}}],["群体配对",{"2":{"66":1}}],["吸引用户",{"2":{"66":1}}],["价值主张",{"2":{"66":1}}],["从该缓冲区中获取数据",{"2":{"148":1}}],["从内存地址处取出值",{"2":{"115":1}}],["从内核栈",{"2":{"93":1}}],["从内核栈恢复寄存器转向用户模式跳到陷阱之后的程序寄存器",{"2":{"89":1}}],["从内核栈恢复寄存器转向用户模式跳到main",{"2":{"89":1}}],["从运行一个进程切换到另一个进程时",{"2":{"113":1}}],["从陷阱返回",{"2":{"93":1}}],["从它的内核栈",{"2":{"93":1}}],["从main返回陷入",{"2":{"89":1}}],["从main中执行return",{"2":{"88":1}}],["从线性的来料",{"2":{"74":1}}],["从而使得后续的调度能够避免产生死锁",{"2":{"170":1}}],["从而使得极小收益的初始购买为后续高收益产品或服务的重复购买创造可能",{"2":{"73":1}}],["从而让等待的写者能够获取该锁",{"2":{"156":1}}],["从而更新数据结构",{"2":{"156":1}}],["从而更好地利用处理器",{"2":{"99":1}}],["从而支持许多并发操作",{"2":{"146":1}}],["从而允许其他线程运行",{"2":{"136":1}}],["从而可以进入临界区",{"2":{"133":1}}],["从而独占处理器",{"2":{"127":1}}],["从而原子地执行",{"2":{"127":1}}],["从而消除不合时宜的中断的可能性",{"2":{"116":1}}],["从而能访问相同的数据",{"2":{"113":1}}],["从而接管机票",{"2":{"110":1}}],["从而尽可能加速服务端执行自己请求的速度",{"2":{"110":1}}],["从而最终获得执行",{"2":{"105":1}}],["从而最大化客流",{"2":{"66":1}}],["从而主动释放cpu",{"2":{"103":1}}],["从而利用工作的历史来预测它未来的行为",{"2":{"100":1}}],["从而为调用进程执行所需的工作",{"2":{"89":1}}],["从而程序开始执行",{"2":{"82":1}}],["从业务转向",{"2":{"62":1}}],["多线程程序在检查条件变量时",{"2":{"150":1}}],["多线程程序会有多个执行点",{"2":{"113":1}}],["多cpu上",{"2":{"131":1}}],["多个程序计数器",{"2":{"113":1}}],["多个收益流",{"2":{"66":1}}],["多级反馈队列",{"0":{"100":1}}],["多种许可证",{"2":{"69":1}}],["多边平台将两个或更多独立但相互依存的客户群体进行连接",{"2":{"63":1}}],["多边平台商业模式总结",{"0":{"66":1}}],["多边平台商业模式",{"0":{"63":1},"1":{"64":1,"65":1,"66":1}}],["三种可行的免费商业模式",{"2":{"67":1}}],["三项关键业务",{"2":{"66":1}}],["三个层次",{"0":{"60":1}}],["电商",{"2":{"65":1}}],["电影",{"2":{"5":1}}],["游戏本体+dlc或平衡性无关道具",{"2":{"73":1}}],["游戏",{"2":{"65":1}}],["联合投稿",{"2":{"65":1}}],["联系我",{"0":{"8":1}}],["评价自旋锁",{"0":{"131":1}}],["评价锁",{"0":{"126":1}}],["评论+回复",{"2":{"65":1}}],["评审管理",{"2":{"54":1}}],["双边",{"2":{"65":1}}],["双重目标",{"2":{"40":1}}],["古典",{"2":{"65":1}}],["淘宝网",{"2":{"65":1}}],["商户会给google付费",{"2":{"64":1}}],["商业模式",{"2":{"65":1,"175":1}}],["商业模式的重构",{"2":{"62":1}}],["商业模式类型",{"0":{"62":1},"1":{"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1}}],["搜索引擎本身对用户是不付费的",{"2":{"64":1}}],["谷歌的商业模式",{"0":{"64":1}}],["天使用户",{"2":{"63":1}}],["网络效应",{"2":{"63":1}}],["促进群体互动创造价值",{"0":{"63":1},"1":{"64":1,"65":1,"66":1}}],["人与人互联的成本极大地降低",{"2":{"62":1}}],["人",{"2":{"62":1}}],["人员管理",{"0":{"55":1}}],["最新笔记",{"0":{"174":1}}],["最新随笔",{"0":{"18":1}}],["最终的生产者",{"0":{"150":1}}],["最简单的硬件支持是测试并设置指令",{"2":{"128":1}}],["最早提供的互斥解决方案之一",{"2":{"127":1}}],["最后一个退出的写者在writelock信号量上调用sem",{"2":{"156":1}}],["最后",{"2":{"115":1}}],["最后将解系统的模型操纵与计算结果用于指导现实世界的问题解决",{"2":{"62":1}}],["最上层队列",{"2":{"102":1}}],["最短完成时间有限",{"0":{"96":1}}],["最短任务有限",{"0":{"95":1}}],["就必须等到所有的读者都结束",{"2":{"156":1}}],["就可以唤醒一个或者多个等待线程",{"2":{"147":1}}],["就可以实现一个锁",{"2":{"132":1}}],["就会让线程睡眠",{"2":{"138":1}}],["就会不断占用cpu",{"2":{"103":1}}],["就降低其优先级",{"2":{"108":1}}],["就将它降到低一优先级的队列中去",{"2":{"107":1}}],["就将系统中所有工作重新加入最高优先级队列",{"2":{"105":1}}],["就转向下一个工作",{"2":{"98":1}}],["就好像是它自己调用了fork",{"2":{"85":1}}],["就绪和阻塞",{"2":{"136":1}}],["就绪和阻塞以外",{"2":{"84":1}}],["就绪",{"2":{"83":1}}],["就是等待线程的个数",{"2":{"152":1}}],["就是它占有资源的份额",{"2":{"109":1}}],["就是所谓的进程",{"2":{"76":1}}],["就是问题域和解系统之间的共享现象",{"2":{"62":1}}],["就产生了问题",{"2":{"62":1}}],["或调用lock",{"2":{"127":1}}],["或关于该线程调度优先级的信息",{"2":{"118":1}}],["或启动",{"2":{"95":1}}],["或",{"2":{"80":1}}],["或模拟",{"2":{"62":1}}],["或者返回",{"2":{"168":1}}],["或者最终用户认为该软件使用效果不良",{"2":{"28":1}}],["或者有任何想法想要交流",{"2":{"8":1}}],["模拟与共享",{"2":{"62":1}}],["成功时",{"2":{"133":1}}],["成为僵尸状态",{"2":{"84":1}}],["成为解系统",{"2":{"62":1}}],["成本",{"2":{"68":1}}],["成本来自于平台的维护和开发",{"2":{"66":1}}],["成长",{"2":{"19":1}}],["解决问题形成的实体和状态就是问题域",{"2":{"62":1}}],["解释软件的故障模型pie",{"0":{"58":1},"1":{"59":1,"60":1}}],["需要给共享变量的访问加锁",{"2":{"160":1}}],["需要一些信号量来解决这个问题",{"2":{"157":1}}],["需要调用rwlock",{"2":{"156":1}}],["需要抢占式的调度器",{"2":{"130":1}}],["需要硬件和操作系统的帮助来实现一个可用的锁",{"2":{"125":1}}],["需要线程控制块tcb保存每个线程的状态",{"2":{"113":1}}],["需要进行调度时",{"2":{"112":1}}],["需要强大品牌",{"2":{"73":1}}],["需要在现实生活中解决问题",{"2":{"62":1}}],["需求",{"2":{"175":1}}],["需求与商业模式创新",{"0":{"61":1},"1":{"62":1,"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1},"2":{"174":1}}],["需求规格说明",{"2":{"36":1}}],["需求分析定义",{"2":{"34":1}}],["当然也可能多个调用线程都调用sem",{"2":{"152":1}}],["当生产者想要填充缓冲区时",{"2":{"148":1}}],["当线程1持有锁l1",{"2":{"162":1}}],["当线程被唤醒时",{"2":{"147":1}}],["当线程想唤醒等待在某个条件变量上的睡眠线程时",{"2":{"147":1}}],["当线程之间必须发生某种信号时",{"2":{"121":1}}],["当它调用sem",{"2":{"153":1}}],["当它改变了上述条件时",{"2":{"147":1}}],["当它优先级提升时",{"2":{"105":1}}],["当某些执行状态",{"2":{"147":1}}],["当持有锁的线程在临界区时",{"2":{"123":1}}],["当工作执行时间很短时",{"2":{"111":1}}],["当操作系统最终执行从陷阱返回指令时",{"2":{"93":1}}],["当前正在进行的进程停止",{"2":{"92":1}}],["当前的主流互联网产品基本都是多边平台商业模式",{"0":{"65":1}}],["当子进程结束时",{"2":{"86":1}}],["当一个进程停止时",{"2":{"84":1}}],["当现实的状况与人们期望的状况产生差距时",{"2":{"62":1}}],["当我不想再学习新的知识的时候",{"2":{"1":1}}],["问题2",{"0":{"90":1},"1":{"91":1,"92":1,"93":1}}],["问题1",{"0":{"89":1}}],["问题的产生地",{"2":{"62":1}}],["问题是人的期望与现实之间的差距",{"2":{"62":1}}],["问题",{"0":{"103":1,"106":1,"148":1,"155":1},"1":{"149":1,"150":1},"2":{"62":1}}],["queue",{"2":{"100":1}}],["quot",{"2":{"58":2}}],["q",{"2":{"62":1}}],["免费商业模式",{"2":{"74":1}}],["免费手机",{"2":{"73":1}}],["免费用户数免费服务成本+增值用户数增值服务成本",{"2":{"71":1}}],["免费用户向增值用户转化率是重要指标",{"2":{"71":1}}],["免费账户的低边际成本服务",{"2":{"71":1}}],["免费的基本服务",{"2":{"67":1}}],["免费的商业模式",{"0":{"67":1},"1":{"68":1,"69":1,"70":1,"71":1,"72":1,"73":1}}],["免费增值模式总结",{"0":{"71":1}}],["免费增值",{"0":{"69":1},"2":{"67":1}}],["免费",{"0":{"62":1},"1":{"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1}}],["由于执行这段代码的多个线程可能导致竞争状态",{"2":{"115":1}}],["由于fault导致的内部状态错误",{"2":{"60":1}}],["由于学习专业的缘故",{"2":{"1":1}}],["错误的中间状态必须传播到最终输出",{"2":{"59":1}}],["错误代码必须要被执行到",{"2":{"59":1}}],["传播",{"2":{"59":1}}],["触发了错误的中间状态",{"2":{"59":1}}],["感染",{"2":{"59":1}}],["感谢你来到我的小角落",{"2":{"8":1}}],["执行main",{"2":{"88":1}}],["执行",{"2":{"59":1}}],["执行了所有测试用例但未发现故障",{"2":{"37":1}}],["give",{"2":{"136":1}}],["github",{"2":{"1":1}}],["game",{"2":{"103":1}}],["goes",{"2":{"85":1}}],["getforks",{"2":{"157":1,"158":1}}],["get",{"2":{"141":1,"148":2,"149":1,"155":1}}],["getpid",{"2":{"85":3,"86":3,"87":3}}],["general",{"2":{"57":1}}],["查看详情",{"2":{"57":1}}],["查出预定数目的故障",{"2":{"37":1}}],["国际标准",{"2":{"57":1}}],["发信号给empty",{"2":{"149":1}}],["发信号量给变量fill",{"2":{"149":1}}],["发出信号以及修改全局变量ready时",{"2":{"121":1}}],["发生这种情况时",{"2":{"99":1}}],["发生时钟中断",{"2":{"93":1}}],["发展思路",{"2":{"72":1}}],["发展阶段",{"2":{"56":1}}],["发现信号量的值为1",{"2":{"154":1}}],["发现锁被占用时",{"2":{"136":1}}],["发现错误",{"2":{"40":1}}],["发现自己并不擅长于技术",{"2":{"1":1}}],["构建从测试人员",{"2":{"55":1}}],["质量管理",{"2":{"54":1}}],["质量优先",{"2":{"7":1}}],["配置管理",{"2":{"54":1}}],["文档管理",{"2":{"54":1}}],["管理维度",{"2":{"54":1}}],["全局计数器有一个",{"2":{"142":1}}],["全方位管理",{"0":{"54":1}}],["全过程管理",{"0":{"53":1}}],["空间维",{"0":{"54":1}}],["说服力",{"2":{"50":1}}],["老练稳重",{"2":{"50":1}}],["判断准确",{"2":{"50":1}}],["创建",{"2":{"77":1}}],["创造性",{"2":{"50":1}}],["创作实验",{"0":{"16":1}}],["故障排除能手",{"2":{"50":1}}],["探索精神",{"2":{"50":1}}],["优秀测试员素质",{"2":{"50":1}}],["node",{"2":{"89":1,"143":3}}],["note",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1},"2":{"0":1,"1":1,"8":2}}],["null",{"2":{"86":1,"87":2,"114":5,"141":1,"143":2}}],["new==null",{"2":{"143":1}}],["new",{"2":{"85":1,"132":2,"143":4}}],["n",{"2":{"85":4,"86":4,"87":5,"114":4,"149":1,"155":1}}],["nie",{"2":{"49":1}}],["x26",{"2":{"114":2,"121":7,"136":1,"141":7,"143":5,"146":3,"149":11,"152":1,"155":11}}],["xv6的proc结构",{"2":{"84":1}}],["xbox",{"2":{"65":1}}],["x模型",{"0":{"47":1}}],["x3c",{"2":{"9":8,"85":4,"86":5,"87":6,"114":3,"118":1,"146":1,"149":2,"152":1,"155":2}}],["敏捷开发模式",{"2":{"43":1}}],["螺旋模式法",{"2":{"43":1}}],["快速原型法",{"2":{"43":1}}],["瀑布法",{"2":{"43":1}}],["瀑布模型阶段",{"2":{"34":1}}],["边写边改法",{"2":{"43":1}}],["大多数情况下默认值null即可",{"2":{"118":1}}],["大多数进程通过系统调用",{"2":{"91":1}}],["大部分客户定期支付小额保费以补贴一小部分产生实际索赔的客户",{"2":{"70":1}}],["大量用户从免费服务获益",{"2":{"69":1}}],["大棒开发法",{"2":{"43":1}}],["大三伊始",{"2":{"1":1}}],["未来发展方向",{"2":{"42":1}}],["对函数成功加上断言",{"2":{"120":1}}],["对这些工作采用轮转调度",{"2":{"100":1}}],["对exec",{"2":{"87":1}}],["对操作系统来说",{"2":{"85":1}}],["对于停止的进程",{"2":{"84":1}}],["对价格为0的商品的需求要数倍于定价为1分钱或更高的商品",{"2":{"67":1}}],["对冲",{"2":{"62":1}}],["对生产者而言",{"2":{"41":1}}],["对消费者而言",{"2":{"41":1}}],["验证需求",{"2":{"40":1}}],["验证测试",{"2":{"32":1}}],["目的在于发现错误",{"2":{"40":1}}],["目的",{"0":{"40":1}}],["目前大学本科在读",{"2":{"2":1}}],["再次增加信号量的值",{"2":{"153":1}}],["再返回调用者",{"2":{"147":1}}],["再考虑是否运行新工作",{"2":{"95":1}}],["再改错",{"2":{"38":1}}],["再测试",{"2":{"38":1}}],["改错",{"2":{"38":1}}],["改错循环",{"2":{"38":1}}],["9",{"0":{"38":1,"109":1,"110":1,"111":1,"112":1,"132":1}}],["9种",{"2":{"32":1}}],["根据单位时间内查出故障的数量决定",{"2":{"37":1}}],["第二阶段调用者会睡眠",{"2":{"139":1}}],["第二个参数是一个指针",{"2":{"119":1}}],["第二类",{"2":{"37":1}}],["第一种简单又好的方法就是",{"2":{"136":1}}],["第一个线程",{"2":{"153":1}}],["第一个线程进入临界区",{"2":{"129":1}}],["第一个参数是pthread",{"2":{"119":1}}],["第一类",{"2":{"37":1}}],["第五类",{"2":{"37":1}}],["第四类",{"2":{"37":1}}],["第三类",{"2":{"37":1}}],["五类停止标准",{"2":{"37":1}}],["8",{"0":{"37":1,"99":1,"100":1,"101":1,"104":1,"107":1,"131":1},"1":{"102":1,"103":1,"105":1,"106":1,"108":1}}],["源程序",{"2":{"36":1}}],["详细设计规格说明",{"2":{"36":1}}],["概要设计规格说明",{"2":{"36":1}}],["7",{"0":{"36":1,"94":1,"95":1,"96":1,"97":1,"98":2,"99":1,"130":1}}],["什么是",{"2":{"62":1}}],["什么是软件测试",{"0":{"30":1}}],["什么是软件缺陷",{"0":{"27":1},"1":{"28":1,"29":1}}],["什么是软件质量",{"0":{"26":1}}],["什么时候进行测试",{"2":{"35":1}}],["四个关键方面",{"0":{"35":1}}],["→",{"2":{"34":7,"38":3}}],["制定计划",{"2":{"34":1}}],["制造业",{"2":{"31":1}}],["6",{"0":{"33":1,"88":1,"89":1,"90":1,"97":1,"112":1,"128":1,"157":1},"1":{"34":1,"35":1,"91":1,"92":1,"93":1,"129":1,"158":1},"2":{"87":1}}],["确认测试",{"2":{"32":1}}],["集成测试",{"2":{"32":1}}],["黑盒测试",{"2":{"32":1}}],["白盒测试工具",{"2":{"51":1}}],["白盒测试",{"2":{"32":1}}],["按照测试策略和过程",{"2":{"32":1}}],["按照测试用例设计方法",{"2":{"32":1}}],["按标签浏览",{"0":{"19":1,"175":1}}],["分支预测器和其他片上硬件中建立了大量的状态",{"2":{"98":1}}],["分配一些内存",{"2":{"80":1}}],["分配内存",{"0":{"80":1}}],["分页和交换机制",{"2":{"79":1}}],["分区+推荐+订阅",{"2":{"65":1}}],["分类体系概览",{"2":{"32":1}}],["分为静态质量属性和动态质量属性",{"2":{"26":1}}],["5tb",{"2":{"69":1}}],["5gb",{"2":{"69":1}}],["5",{"0":{"32":1,"84":1,"85":1,"86":1,"87":1,"96":1,"117":1,"122":1,"127":1,"156":1},"2":{"157":2}}],["eat",{"2":{"157":1}}],["eax",{"2":{"115":6}}],["empty的唤醒和等待操作调用到锁外面",{"2":{"155":1}}],["empty",{"2":{"149":3,"155":4}}],["else",{"2":{"85":2,"86":2,"87":2,"158":1}}],["error",{"2":{"60":1}}],["engineering",{"2":{"57":2}}],["evaluation",{"2":{"56":1}}],["education",{"2":{"31":1,"56":1}}],["expected",{"2":{"132":2,"138":1}}],["export",{"2":{"22":1}}],["exchange",{"2":{"128":1}}],["exclusion",{"2":{"115":1,"126":1}}],["execvp",{"2":{"87":2}}],["exec",{"0":{"87":1},"2":{"87":1}}],["execution",{"0":{"88":1},"2":{"59":1}}],["exit",{"2":{"85":2,"86":1,"87":1}}],["extensions",{"2":{"21":1,"24":1}}],["extension",{"0":{"21":1},"1":{"22":1,"23":1,"24":1}}],["examples",{"0":{"9":1,"21":1},"1":{"10":1,"11":1,"12":1,"13":1,"14":1,"22":1,"23":1,"24":1}}],["医疗等各行各业",{"2":{"31":1}}],["农业",{"2":{"31":1}}],["教育",{"2":{"31":1}}],["显示软件执行正确",{"2":{"30":1}}],["找出缺陷和故障",{"2":{"30":1}}],["✅",{"2":{"30":2}}],["测试并设置指令",{"0":{"128":1},"1":{"129":1}}],["测试小组到测试机构的多层次组织管理模式",{"2":{"55":1}}],["测试结果管理",{"2":{"53":1}}],["测试执行管理",{"2":{"53":1}}],["测试设计管理",{"2":{"53":1}}],["测试计划管理",{"2":{"53":1}}],["测试用例设计工具",{"2":{"51":1}}],["测试管理工具",{"2":{"51":1}}],["测试管理全面化",{"2":{"42":1}}],["测试工具类型",{"2":{"51":1}}],["测试工具服务化",{"2":{"42":1}}],["测试信息流程",{"0":{"48":1}}],["测试对象精细化",{"2":{"42":1}}],["测试对象范围",{"2":{"36":1}}],["测试部门独立化",{"2":{"42":1}}],["测试人员专业化",{"2":{"42":1}}],["测试过程标准化",{"2":{"42":1}}],["测试手段多样化",{"2":{"42":1}}],["测试理论系统化",{"2":{"42":1}}],["测试方法工具化",{"2":{"42":1}}],["测试技术智能化",{"2":{"42":1}}],["测试不能证明程序的正确性",{"2":{"40":1}}],["测试是程序的执行过程",{"2":{"40":1}}],["测试是一个或多个测试用例的结合",{"2":{"30":1}}],["测试",{"2":{"38":2}}],["测试超过了预期时间",{"2":{"37":1}}],["测试什么",{"2":{"35":1}}],["测试由谁来执行",{"2":{"35":1}}],["测试的普遍性",{"0":{"31":1}}],["测试活动有两种结果",{"2":{"30":1}}],["官方定义",{"2":{"30":1}}],["32",{"0":{"159":1,"162":1},"1":{"160":1,"161":1,"163":1,"164":1,"165":1,"166":1,"167":1,"168":1,"169":1,"170":1,"171":1,"172":1}}],["31",{"0":{"152":1,"153":1,"154":1,"155":1,"156":1,"157":1},"1":{"158":1}}],["30",{"0":{"147":1,"148":1,"151":1},"1":{"149":1,"150":1}}],["30+种",{"2":{"32":2}}],["3",{"0":{"30":1,"78":1,"87":1,"90":1,"94":1,"104":1,"111":1,"115":1,"120":1,"125":1,"145":1,"151":1,"154":1,"162":1},"1":{"79":1,"80":1,"81":1,"82":1,"91":1,"92":1,"93":1,"105":1,"106":1,"163":1,"164":1,"165":1,"166":1,"167":1,"168":1,"169":1,"170":1,"171":1,"172":1},"2":{"87":1}}],["随着整个开发过程的时间推移",{"2":{"28":1}}],["随笔",{"2":{"19":1}}],["随笔角落",{"0":{"17":1},"1":{"18":1,"19":1}}],["点击查看5条定义标准",{"2":{"28":1}}],["如此便可以保持在高优先级",{"2":{"103":1}}],["如此下去",{"2":{"95":1}}],["如发出i",{"2":{"89":1}}],["如cpu或内存",{"2":{"89":1}}],["如向磁盘发出i",{"2":{"89":1}}],["如文件操作符",{"2":{"81":1}}],["如何让锁不会不必要地自旋",{"2":{"135":1}}],["如何阻止调度程序被愚弄",{"2":{"107":1}}],["如何改变优先级",{"0":{"101":1},"1":{"102":1,"103":1}}],["如何构建对响应时间敏感的调度程序",{"2":{"97":1}}],["如何重获cpu的控制权",{"2":{"90":1}}],["如何设计收益流补贴并定价",{"2":{"66":1}}],["如何管理",{"0":{"27":1},"1":{"28":1,"29":1}}],["如果这4个条件的任何一个没有满足",{"2":{"164":1}}],["如果哲学家p希望用左手边的叉子",{"2":{"157":1}}],["如果某个线程要更新数据结构",{"2":{"156":1}}],["如果线程0持有锁",{"2":{"153":1}}],["如果方案带来了更大的开销",{"2":{"144":1}}],["如果第一个自旋阶段没有获得锁",{"2":{"139":1}}],["如果address处的值等于expected",{"2":{"138":1}}],["如果a的优先级=b的优先级",{"2":{"100":1}}],["如果a的优先级＞b的优先级",{"2":{"100":1}}],["如果临界区的线程发生上下文切换",{"2":{"136":1}}],["如果有n个线程去竞争一个锁",{"2":{"135":1}}],["如果有等待线程",{"2":{"123":1,"152":1}}],["如果成功",{"2":{"133":1}}],["如果是",{"2":{"132":1}}],["如果另外一个线程对相同的锁变量调用lock",{"2":{"123":1}}],["如果另一个线程确实持有该锁",{"2":{"120":1}}],["如果没有其他线程尝试获取锁",{"2":{"153":1}}],["如果没有其他线程持有锁",{"2":{"123":1}}],["如果没有其他等待线程",{"2":{"123":1}}],["如果没有",{"2":{"121":1}}],["如果在调用pthread",{"2":{"120":1}}],["如果一个核心上的线程想增加计数器",{"2":{"142":1}}],["如果一个线程在等待另一个线程继续执行某些操作",{"2":{"121":1}}],["如果一个cpu密集型工作变成了交互型",{"2":{"105":1}}],["如果一个工作长时间地占用cpu",{"2":{"100":1}}],["如果一个工作不断放弃cpu",{"2":{"100":1}}],["如果系统有太多交互型工作",{"2":{"103":1}}],["如果确实是短工作",{"2":{"102":1}}],["如果不知道工作是短工作还是长工作",{"2":{"102":1}}],["如果工作在其时间片以内主动释放cpu",{"2":{"102":1}}],["如果将i",{"2":{"99":1}}],["如果响应时间是唯一指标",{"2":{"98":1}}],["如果知道任务时长",{"2":{"96":1}}],["如果应用呈持续执行了某些非法操作",{"2":{"91":1}}],["如果进程希望执行某种受限操作",{"2":{"89":1}}],["如果你喜欢我的文字",{"2":{"8":1}}],["如果可以的话",{"2":{"1":1}}],["其中每个cpu核心有一个局部计数器",{"2":{"142":1}}],["其中一个会注意到锁状态的变化",{"2":{"123":1}}],["其中两个线程希望更新全局变量",{"2":{"114":1}}],["其中有些属性比另外一些属性重要",{"2":{"26":1}}],["其次",{"2":{"105":1}}],["其他的读者也可以获取这个读锁",{"2":{"156":1}}],["其他线程只能一直自旋",{"2":{"136":1}}],["其他线程就无法进入临界区",{"2":{"123":1}}],["其他线程将被阻止进入临界区",{"2":{"115":1}}],["其他初始化任务",{"0":{"81":1}}],["其他控制",{"2":{"77":1}}],["其他方面补贴免费产品",{"0":{"67":1},"1":{"68":1,"69":1,"70":1,"71":1,"72":1,"73":1}}],["其他群体的存在",{"2":{"63":1}}],["其作用类似于天使投资",{"2":{"63":1}}],["其目的在于检验软件是否满足规定的需求或弄清预期结果和实际结果之间的差别",{"2":{"30":1}}],["其实网易产品",{"2":{"1":1}}],["其实不那么准确",{"2":{"1":1}}],["可扩展的计数",{"0":{"142":1}}],["可能降低的并发",{"2":{"167":1}}],["可能会影响性能",{"2":{"151":1}}],["可能会导致饿死",{"2":{"131":1}}],["可能会导致严重的系统问题",{"2":{"127":1}}],["可能每次都会得到不同的结果",{"2":{"115":1}}],["可以构造出不需要锁的数据结构",{"2":{"169":1}}],["可以构造出两个线程都将标志设置为1",{"2":{"129":1}}],["可以降低线程之间的重复互相干扰",{"2":{"168":1}}],["可以在循环结束的时候先随机等待一个时间",{"2":{"168":1}}],["可以用两个函数来操作它",{"2":{"152":1}}],["可以使用条件变量cond和相关的锁mutex",{"2":{"148":1}}],["可以保证临界区的代码不会被中断",{"2":{"127":1}}],["可以进行上下文切换",{"2":{"95":1}}],["可以恢复运行该进程",{"2":{"84":1}}],["可观的固定成本",{"2":{"71":1}}],["可选的增值服务",{"2":{"67":1}}],["可度量的多维度的量",{"2":{"26":1}}],["可是打开招聘网站",{"2":{"1":1}}],["软件依靠业务来创造价值",{"2":{"62":1}}],["软件系统中含有问题域某些部分的模型",{"2":{"62":1}}],["软件系统中的某些部分对问题域中的某些部分的具有模拟特性",{"2":{"62":1}}],["软件系统通过影响问题域帮助人们解决问题",{"2":{"62":1}}],["软件解决问题的基础",{"2":{"62":1}}],["软件中存在的静态错误",{"2":{"60":1}}],["软件开发过程中所产生的所有文档和代码都是测试对象",{"2":{"36":1}}],["软件停用",{"2":{"34":1}}],["软件维护",{"2":{"34":1}}],["软件运行",{"2":{"34":1}}],["软件设计",{"2":{"34":1}}],["软件生命周期8阶段",{"0":{"34":1}}],["软件",{"2":{"31":1}}],["软件缺陷修复的代价",{"2":{"28":1}}],["软件缺陷的定义",{"0":{"28":1}}],["软件测试作为一种职业和科学",{"0":{"50":1}}],["软件测试在软件工程中的位置",{"0":{"43":1}}],["软件测试自动化",{"2":{"42":1}}],["软件测试",{"2":{"34":1}}],["软件测试的标准规范",{"0":{"57":1}}],["软件测试的历史演进",{"0":{"56":1}}],["软件测试的管理框架",{"0":{"52":1},"1":{"53":1,"54":1,"55":1}}],["软件测试的工具分类",{"0":{"51":1}}],["软件测试的研究进展",{"0":{"49":1}}],["软件测试的过程",{"0":{"48":1}}],["软件测试的模型",{"0":{"44":1},"1":{"45":1,"46":1,"47":1}}],["软件测试的未来发展趋势",{"0":{"42":1}}],["软件测试的目的",{"0":{"39":1},"1":{"40":1,"41":1}}],["软件测试的周期性和并行性",{"0":{"38":1}}],["软件测试的停止准则有哪些",{"0":{"37":1}}],["软件测试的对象是什么",{"0":{"36":1}}],["软件测试的关键问题是什么",{"0":{"33":1},"1":{"34":1,"35":1}}],["软件测试的种类",{"0":{"32":1}}],["软件测试的主要目的",{"2":{"29":1}}],["软件测试人员认为软件难以理解",{"2":{"28":1}}],["软件测试核心概念",{"0":{"25":1},"1":{"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1}}],["软件功能超出了产品说明书中指明的范围",{"2":{"28":1}}],["软件未达到产品说明书中虽未指出但应当达到的目标",{"2":{"28":1}}],["软件未达到产品说明书中已经标明的功能",{"2":{"28":1}}],["软件出现了产品说明书中指明不会出现的错误",{"2":{"28":1}}],["软件质量是一个包含多个属性的",{"2":{"26":1}}],["定义",{"2":{"26":1}}],["```",{"2":{"22":1}}],["4",{"0":{"31":1,"75":1,"77":1,"78":1,"83":2,"84":1,"95":1,"107":1,"116":1,"121":1,"126":1,"146":1,"155":1},"1":{"76":1,"79":1,"80":1,"81":1,"82":1,"108":1},"2":{"22":1}}],["九月小记",{"0":{"20":1}}],["窗台上的绿意",{"2":{"18":1}}],["1个时间片",{"2":{"135":1}}],["1e7",{"2":{"114":1}}],["1990s",{"2":{"56":1}}],["1980s",{"2":{"56":1}}],["1970s",{"2":{"56":1}}],["1960s",{"2":{"56":1}}],["1950s",{"2":{"56":1}}],["19",{"0":{"56":1}}],["17",{"0":{"51":1}}],["16",{"0":{"50":1,"139":1}}],["14",{"0":{"48":1,"137":1}}],["13",{"0":{"44":1,"136":1},"1":{"45":1,"46":1,"47":1}}],["11",{"0":{"42":1,"134":1}}],["101",{"2":{"146":1}}],["100gb",{"2":{"69":1}}],["10",{"0":{"39":1,"133":1},"1":{"40":1,"41":1}}],["1",{"0":{"26":1,"75":1,"85":1,"88":1,"100":1,"109":1,"113":1,"118":1,"123":1,"140":1,"147":1,"152":1},"1":{"76":1,"141":1,"142":1},"2":{"57":2,"85":1,"86":1,"87":2,"115":2,"136":1,"143":1,"152":1,"154":1,"155":1,"157":1,"168":1}}],["12",{"0":{"43":1,"135":1},"2":{"18":1}}],["15",{"0":{"49":1,"138":1},"2":{"18":1}}],["18",{"0":{"52":1},"1":{"53":1,"54":1,"55":1},"2":{"18":1}}],["0x1",{"2":{"115":1}}],["0x8049a1c",{"2":{"115":2}}],["0",{"2":{"85":2,"86":2,"87":4,"114":3,"133":1,"136":1,"141":1,"143":1,"148":2,"149":2,"152":1,"155":5}}],["01",{"2":{"18":4}}],["09",{"2":{"15":1,"20":1,"174":2}}],["雨天的阅读角落",{"2":{"18":1}}],["23",{"2":{"174":1}}],["24",{"2":{"174":1}}],["29",{"0":{"140":1,"143":1,"145":1,"146":1},"1":{"141":1,"142":1,"144":1}}],["29119",{"2":{"57":1}}],["28",{"0":{"123":1,"124":1,"125":1,"126":1,"127":1,"128":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1},"1":{"129":1}}],["27",{"0":{"118":1,"119":1,"120":1,"121":1,"122":1}}],["26",{"0":{"113":1,"114":1,"115":1,"116":1,"117":1}}],["21",{"0":{"58":1},"1":{"59":1,"60":1}}],["2",{"0":{"27":1,"62":1,"77":1,"86":1,"89":1,"101":1,"110":1,"114":1,"119":1,"124":1,"143":1,"148":1,"153":1,"159":1},"1":{"28":1,"29":1,"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"102":1,"103":1,"144":1,"149":1,"150":1,"160":1,"161":1},"2":{"57":1,"87":1}}],["2014",{"2":{"49":1}}],["2007",{"2":{"49":1}}],["2000+",{"2":{"56":1}}],["2000",{"2":{"49":1}}],["20+种",{"2":{"32":1}}],["20",{"0":{"57":1},"2":{"18":1}}],["2021",{"2":{"57":1}}],["2024",{"2":{"18":4}}],["2025",{"2":{"15":1,"20":1,"174":3}}],["25",{"2":{"15":1,"20":1}}],["今日无事",{"0":{"15":1}}],["l",{"2":{"143":12}}],["left",{"2":{"157":1,"158":2}}],["level",{"2":{"100":1}}],["lesson",{"0":{"62":1},"1":{"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1}}],["loops",{"2":{"149":2,"155":2}}],["lookup",{"2":{"143":1,"146":2}}],["locking",{"2":{"144":1}}],["lock",{"0":{"130":1},"2":{"120":3,"121":8,"123":1,"133":1,"136":1,"141":4,"143":2,"144":1,"149":1,"156":2}}],["load",{"0":{"79":1}}],["lofter",{"2":{"1":1}}],["livelock",{"2":{"168":1}}],["linux提供了futex",{"2":{"138":1}}],["linked和条件式存储store",{"2":{"133":1}}],["line",{"2":{"22":1}}],["limited",{"0":{"88":1}}],["like",{"2":{"22":1}}],["lists",{"2":{"146":1}}],["list",{"2":{"14":1,"24":1,"143":6,"146":4}}],["ostep",{"2":{"174":1}}],["os将cpu的控制权转移到新创建的进程中",{"2":{"82":1}}],["order",{"0":{"161":1}}],["oriented",{"2":{"56":5}}],["over",{"2":{"144":1}}],["o操作",{"2":{"103":1}}],["o的进程从阻塞状态移回就绪状态",{"2":{"99":1}}],["o负载",{"2":{"99":1}}],["o发送到硬盘驱动器",{"2":{"99":1}}],["o完成时使用cpu",{"2":{"99":1}}],["o完成时做出决定",{"2":{"99":1}}],["o完成",{"2":{"99":1}}],["o期间不会使用cpu",{"2":{"99":1}}],["o请求时做出决定",{"2":{"99":1}}],["o请求和执行所有类型的受限指令",{"2":{"89":1}}],["o请求",{"2":{"89":1}}],["o请求或获得更多系统资源",{"2":{"89":1}}],["o",{"0":{"99":1},"2":{"81":1}}],["onedrive",{"2":{"69":1}}],["output",{"2":{"22":1,"23":1}}],["out",{"2":{"14":1,"24":1,"87":1}}],["of",{"2":{"9":2,"14":1,"21":1,"24":1,"85":1,"86":1,"87":1}}],["right",{"2":{"157":1,"158":2}}],["rv",{"2":{"143":3}}],["rr几乎是最差的",{"2":{"98":1}}],["rr所作的正是延伸每个工作",{"2":{"98":1}}],["rr十分糟糕",{"2":{"98":1}}],["rr在响应时间上表现越好",{"2":{"98":1}}],["rr在一个时间片",{"2":{"98":1}}],["rr有时被称为时间切片",{"2":{"98":1}}],["rr调度",{"0":{"98":1}}],["routine和arg",{"2":{"118":1}}],["routine",{"2":{"118":2}}],["round",{"0":{"98":1}}],["robin",{"0":{"98":1}}],["rc==0",{"2":{"85":1,"86":1,"87":1}}],["rc",{"2":{"85":3,"86":3,"87":3,"141":2}}],["running正在执行指令",{"2":{"83":1}}],["run",{"2":{"80":1}}],["runtime",{"0":{"9":1},"1":{"10":1,"11":1,"12":1,"13":1,"14":1},"2":{"9":1,"14":1}}],["release",{"2":{"156":1}}],["reader",{"2":{"156":1}}],["ready=1",{"2":{"121":1}}],["ready==0",{"2":{"121":1}}],["ready进程已准备好运行",{"2":{"83":1}}],["redhat",{"2":{"69":1}}],["research",{"2":{"56":1}}],["results",{"0":{"10":1},"1":{"11":1,"12":1,"13":1},"2":{"9":1}}],["return",{"2":{"22":2,"85":1,"86":1,"87":1,"114":2,"132":1,"141":1,"143":2,"146":2,"148":1,"157":2}}],["==1",{"2":{"136":1}}],["==",{"2":{"132":1}}],["=",{"2":{"9":1,"71":3,"85":1,"86":2,"87":5,"114":3,"121":2,"132":2,"136":1,"141":2,"143":9,"146":2,"148":3,"149":3,"155":2}}],["flag",{"2":{"136":2}}],["flag=0",{"2":{"136":1}}],["fprintf",{"2":{"85":1,"86":1,"87":1}}],["fill",{"2":{"149":3}}],["file",{"2":{"87":1}}],["files",{"2":{"9":1}}],["fifo",{"0":{"94":1}}],["final",{"2":{"84":1}}],["fairness",{"2":{"126":1}}],["fair",{"2":{"98":1}}],["failed",{"2":{"85":2,"86":1,"87":1}}],["failure",{"2":{"60":1}}],["facebook大幅增长的广告收益",{"2":{"68":1}}],["fault",{"2":{"60":1}}],["fse",{"2":{"49":2}}],["features",{"2":{"22":1}}],["full",{"2":{"14":1,"24":1,"155":4}}],["frontmatter",{"0":{"13":1},"2":{"9":3,"13":1}}],["from",{"2":{"9":1}}],["forks",{"2":{"157":1,"158":4}}],["fork",{"0":{"85":1},"2":{"85":3,"86":2,"87":2}}],["for",{"2":{"9":1,"14":1,"24":1,"114":1,"146":1,"149":2,"155":2}}],["violation",{"0":{"160":1,"161":1}}],["vitepress",{"2":{"9":2,"21":1,"22":1}}],["value",{"2":{"141":1,"148":2}}],["variable",{"0":{"121":1},"2":{"123":1,"147":1}}],["void",{"2":{"114":2,"118":3,"136":2,"141":3,"143":1,"146":1,"148":1,"149":4,"155":4}}],["volatile",{"2":{"114":1}}],["v模型",{"0":{"45":1}}],["vs",{"2":{"32":1,"65":1}}],["vue",{"2":{"9":1}}],["mutex",{"2":{"120":7,"121":8,"124":1,"141":8,"143":5,"149":11,"155":6}}],["mutual",{"2":{"115":1,"126":1}}],["mythread",{"2":{"114":3}}],["mythreads",{"2":{"114":1}}],["myargs",{"2":{"87":6}}],["mlfq近似于sjf",{"2":{"102":1}}],["mlfq的两条基本规则",{"2":{"100":1}}],["mlfq在进程运行过程中学习其行为",{"2":{"100":1}}],["mlfq会降低其优先级",{"2":{"100":1}}],["mlfq调度策略的关键在于如何设置优先级",{"2":{"100":1}}],["mlfq总是优先执行较高优先级的工作",{"2":{"100":1}}],["mlfq中有许多独立的队列",{"2":{"100":1}}],["mlfq",{"0":{"100":1},"2":{"100":1}}],["ms中断cpu",{"2":{"93":1}}],["msg",{"2":{"22":2}}],["mov",{"2":{"115":1}}],["mode",{"2":{"89":1}}],["more",{"0":{"14":1,"24":1}}],["miscellaneous",{"2":{"77":1}}],["metro",{"2":{"68":1}}],["md```js",{"2":{"22":1}}],["md",{"2":{"9":2,"23":1}}],["max",{"2":{"155":1}}],["malloc",{"2":{"143":2}}],["main",{"2":{"9":1,"85":2,"86":1,"87":1,"88":1,"114":3,"155":1}}],["markdown",{"0":{"21":1},"1":{"22":1,"23":1,"24":1},"2":{"1":1,"21":1,"24":1}}],["i=0",{"2":{"146":1,"155":1}}],["i++",{"2":{"114":1,"146":1,"149":2,"155":2}}],["if语句可能会对",{"2":{"150":1}}],["if",{"2":{"85":2,"86":2,"87":2,"132":1,"143":2,"149":2,"158":1}}],["i",{"2":{"81":1,"85":2,"86":2,"87":2,"114":3,"146":3,"149":7,"155":6}}],["iec",{"2":{"57":3}}],["ieee",{"2":{"57":4}}],["iso",{"2":{"57":3}}],["is",{"2":{"23":10}}],["import",{"2":{"9":1}}],["insert",{"2":{"143":1,"146":2}}],["instruction",{"2":{"128":1}}],["increment",{"2":{"141":1}}],["include",{"2":{"85":3,"86":4,"87":5,"114":3,"118":1,"152":1}}],["init",{"2":{"136":1,"141":2,"143":2,"146":2,"152":1,"155":3}}],["initializer",{"2":{"121":2}}],["initial",{"2":{"84":1}}],["int",{"2":{"85":6,"86":7,"87":7,"114":4,"118":1,"120":1,"121":1,"132":4,"141":3,"143":4,"146":7,"148":3,"149":3,"155":5,"157":4}}],["international",{"2":{"57":2}}],["inflation",{"2":{"110":1}}],["infection",{"2":{"59":1}}],["info",{"2":{"23":4}}],["industrial",{"2":{"31":1}}],["input",{"2":{"22":1,"23":1}}],["in",{"2":{"9":1,"21":1}}],["it",{"2":{"9":1}}],["writelock",{"2":{"156":1}}],["writer",{"2":{"156":1}}],["while",{"2":{"121":1,"136":1,"143":1}}],["wc",{"2":{"86":3,"87":5}}],["world",{"2":{"85":1,"86":1,"87":1}}],["works",{"2":{"9":1}}],["wake",{"2":{"138":1}}],["waiting",{"2":{"147":1}}],["wait",{"0":{"86":1},"2":{"77":1,"86":3,"87":2,"121":3,"138":1,"147":3,"149":3,"152":4,"153":3,"154":6,"155":4,"158":4}}],["warning",{"2":{"23":6}}],["wii",{"2":{"65":1}}],["with",{"2":{"22":1,"114":1}}],["w模型",{"0":{"46":1}}],["wx公众号",{"2":{"8":1}}],["direct",{"0":{"88":1}}],["done",{"2":{"114":2}}],["down",{"2":{"85":1}}],["documentation",{"2":{"14":1,"24":1}}],["d",{"2":{"85":4,"86":5,"87":5,"114":2,"149":1,"155":1}}],["dangerous",{"2":{"23":2}}],["danger",{"2":{"23":2}}],["data",{"0":{"11":1,"12":1},"2":{"9":3,"22":2}}],["deadlock",{"0":{"162":1},"1":{"163":1,"164":1,"165":1,"166":1,"167":1,"168":1,"169":1,"170":1,"171":1,"172":1}}],["define",{"2":{"146":1}}],["default",{"2":{"22":2}}],["decrement",{"2":{"141":1}}],["destroy",{"2":{"77":1}}],["destruction",{"2":{"56":1}}],["demonstration",{"2":{"56":1}}],["demonstrates",{"2":{"9":1,"21":1}}],["debugging",{"2":{"56":1}}],["details",{"2":{"23":4}}],["summer",{"2":{"174":1}}],["sem",{"2":{"152":4,"153":1,"155":13,"157":1,"158":4}}],["semaphore",{"2":{"152":1}}],["set",{"2":{"128":1}}],["setup>",{"2":{"9":1}}],["s越大",{"2":{"142":1}}],["s越小",{"2":{"142":1}}],["spin",{"0":{"130":1}}],["space",{"2":{"76":1}}],["sizeof",{"2":{"143":1}}],["signal",{"2":{"121":2,"149":2,"151":1}}],["site",{"2":{"9":1}}],["s",{"2":{"114":2,"152":2}}],["s设置得太高",{"2":{"106":1}}],["s的值应该如何设置",{"2":{"106":1}}],["scheduling",{"2":{"112":1}}],["scheduler",{"2":{"103":1}}],["script>",{"2":{"9":1}}],["script",{"2":{"9":1}}],["slice",{"2":{"98":1}}],["sjf是最优的",{"2":{"96":1}}],["sjf是一个最优调度算法",{"2":{"95":1}}],["sjf",{"0":{"95":1}}],["store",{"2":{"133":1}}],["stcf和相关方法再响应时间上并不是很好",{"2":{"97":1}}],["stcf是一个很好的策略",{"2":{"96":1}}],["stcf的最优性是符合直觉的",{"2":{"96":1}}],["stcf",{"0":{"96":1}}],["struct",{"2":{"141":1,"146":1}}],["stride",{"2":{"112":1}}],["string",{"2":{"87":1}}],["strdup",{"2":{"87":2}}],["stderr",{"2":{"85":1,"86":1,"87":1}}],["stdlib",{"2":{"85":1,"86":1,"87":1}}],["stdio",{"2":{"85":1,"86":1,"87":1,"114":1}}],["start",{"2":{"118":2}}],["static",{"2":{"114":1}}],["status",{"2":{"77":1}}],["stack",{"2":{"80":2}}],["standard",{"2":{"57":3}}],["switch",{"2":{"84":1,"93":1}}],["sys",{"2":{"86":1,"87":1}}],["systems",{"2":{"57":2}}],["syntax",{"0":{"22":1},"2":{"22":1}}],["software",{"2":{"57":4}}],["social",{"2":{"31":1}}],["some",{"2":{"9":1,"21":1}}],["shouldn",{"2":{"87":1}}],["shopping",{"2":{"31":1}}],["shiki",{"2":{"22":1}}],["avoidance",{"2":{"170":1}}],["assert",{"2":{"148":2}}],["atomicity",{"0":{"160":1}}],["atomic",{"2":{"128":1}}],["attr用于指定该线程可能具有的任何属性",{"2":{"118":1}}],["attr",{"2":{"118":3}}],["am",{"2":{"85":2,"86":2,"87":2}}],["amp",{"0":{"73":1},"2":{"65":2,"67":1,"73":1}}],["arg是传递给线程开始执行的函数的参数",{"2":{"118":1}}],["arg",{"2":{"114":3,"118":1,"149":2,"155":2}}],["argument",{"2":{"87":1}}],["argv设置程序栈",{"2":{"88":1}}],["argv",{"2":{"85":1,"86":1,"87":1,"114":1,"155":1}}],["argc",{"2":{"85":1,"86":1,"87":1,"114":1,"155":1}}],["add指令",{"2":{"134":1}}],["add",{"2":{"115":1}}],["address",{"2":{"76":1,"138":2}}],["additional",{"2":{"22":1}}],["adwords",{"2":{"64":1}}],["acquire",{"2":{"156":1}}],["actual",{"2":{"132":3}}],["academic",{"2":{"31":1}}],["access",{"2":{"9":1}}],["a",{"2":{"23":8,"62":1,"93":4,"114":1}}],["an",{"2":{"23":2}}],["and",{"2":{"9":2,"56":1,"57":2,"128":1,"134":1}}],["apis",{"2":{"9":1,"14":1}}],["api",{"0":{"9":1},"1":{"10":1,"11":1,"12":1,"13":1,"14":1},"2":{"9":1}}],["trylock",{"2":{"168":1}}],["transfer",{"2":{"110":1}}],["trap",{"2":{"89":1}}],["tmp",{"2":{"149":2,"155":2}}],["typedef",{"2":{"146":1}}],["t类型",{"2":{"119":1}}],["t结构类型的指针",{"2":{"118":1}}],["tlb",{"2":{"98":1}}],["t",{"2":{"87":1,"114":1,"118":2,"120":2,"121":5,"141":7,"143":6,"146":6,"149":2,"152":1,"155":3,"157":1}}],["ticket",{"2":{"110":3}}],["time",{"2":{"80":1,"98":1}}],["tip",{"2":{"23":4}}],["testandset",{"2":{"136":1}}],["testing",{"2":{"57":2}}],["test",{"2":{"57":2,"128":1}}],["to",{"2":{"9":1,"87":1}}],["think",{"2":{"157":1}}],["this",{"2":{"9":1,"21":1,"23":10,"85":1,"87":1}}],["thread是指向pthread",{"2":{"118":1}}],["thread",{"2":{"118":2}}],["theme",{"0":{"11":1},"2":{"9":4,"11":1}}],["the",{"2":{"9":3,"14":2,"21":1,"24":2,"103":1,"136":1}}],["broadcast",{"2":{"151":1}}],["break",{"2":{"143":1}}],["b",{"2":{"93":4,"114":1}}],["b站上的用户互动",{"2":{"65":1}}],["buffer",{"2":{"148":3}}],["bucket",{"2":{"146":4}}],["buckets",{"2":{"146":5}}],["bug",{"2":{"58":1}}],["built",{"2":{"21":1}}],["block",{"2":{"23":2,"83":1}}],["box",{"2":{"23":2}}],["both",{"2":{"9":1,"114":1}}],["begin",{"2":{"114":2}}],["be",{"2":{"9":1}}],["by",{"2":{"9":1,"21":1,"22":1}}],["p==4",{"2":{"158":1}}],["p+1",{"2":{"157":1}}],["p",{"2":{"157":5,"158":4}}],["putforks",{"2":{"157":1}}],["put",{"2":{"148":2,"149":1,"155":1}}],["put函数假设缓冲区是空的",{"2":{"148":1}}],["perror",{"2":{"143":1}}],["performance",{"2":{"126":1}}],["ptr",{"2":{"132":3}}],["pthread锁",{"0":{"124":1}}],["pthread标记",{"2":{"122":1}}],["pthread",{"2":{"114":6,"118":4,"120":4,"121":14,"141":8,"143":5,"149":8}}],["post",{"2":{"152":2,"153":3,"154":4,"155":4,"156":1}}],["posix的lock和unlock函数会传入一个变量",{"2":{"124":1}}],["posix库将锁称为互斥量",{"2":{"124":1}}],["powered",{"2":{"22":1}}],["p2",{"2":{"114":3}}],["p1",{"2":{"114":3}}],["p3",{"2":{"87":1}}],["pid",{"2":{"85":3,"86":3,"87":3}}],["pie名称由来",{"0":{"59":1}}],["pie模型对",{"2":{"58":1}}],["pie模型细分",{"2":{"58":1}}],["pcb",{"2":{"84":1}}],["ps",{"2":{"65":1}}],["path",{"2":{"85":1}}],["parent",{"2":{"85":2,"86":1,"87":1}}],["part",{"2":{"57":2}}],["page",{"0":{"12":1,"13":1},"2":{"9":7,"12":1,"21":1}}],["pages搭建一个静态的个人主页",{"2":{"1":1}}],["priority",{"2":{"100":1}}],["print",{"2":{"87":1}}],["printf",{"2":{"85":3,"86":3,"87":4,"114":4,"149":1,"155":1}}],["prevention",{"2":{"56":1}}],["pre>",{"2":{"9":6}}],["program",{"2":{"87":1}}],["process",{"0":{"76":1},"2":{"85":1}}],["processes",{"2":{"57":1}}],["propagation",{"2":{"59":1}}],["professional",{"2":{"56":1}}],["producer",{"2":{"148":1,"149":1,"155":1}}],["produce",{"2":{"31":1}}],["provides",{"2":{"22":1}}],["provided",{"2":{"9":1,"21":1}}],["在大型的代码库中",{"2":{"163":1}}],["在现代代码集中加入这种同步",{"2":{"161":1}}],["在posix标准中",{"2":{"152":1}}],["在另外某个线程发信号给它时",{"2":{"147":1}}],["在4个cpu的机器上",{"2":{"142":1}}],["在许多线程反复竞争一把锁的情况下",{"2":{"136":1}}],["在这个例子中",{"2":{"136":1}}],["在这种方法中",{"2":{"136":1}}],["在这3条指令中",{"2":{"115":1}}],["在要自旋的时候",{"2":{"136":1}}],["在单处理器上",{"2":{"130":1}}],["在临界区关闭中断",{"2":{"127":1}}],["在调用上述任何一个函数时",{"2":{"121":1}}],["在出现问题时不能简单地退出",{"2":{"120":1}}],["在竞争环境中",{"2":{"110":1}}],["在最高优先级队列中",{"2":{"105":1}}],["在周转时间这类指标上表现不佳",{"2":{"98":1}}],["在返回时",{"2":{"93":1}}],["在进程之间切换",{"0":{"90":1},"1":{"91":1,"92":1,"93":1}}],["在进程列表上创建条目为程序分配内存将程序加载到内存中根据argv设置程序栈用寄存器",{"2":{"89":1}}],["在进程列表上创建条目为程序分配内存将程序加载到内存中根据argc",{"2":{"88":1}}],["在此模式下",{"2":{"89":1}}],["在用户模式下运行时",{"2":{"89":1}}],["在用户模式下运行的代码会受到限制",{"2":{"89":1}}],["在各个领域都需要测试",{"2":{"31":1}}],["在每一个平凡的日子里",{"2":{"8":1}}],["在海外的留子姐妹已经过上了履历丰富",{"2":{"1":1}}],["愿这里的文字能带给你一丝温暖和启发",{"2":{"8":1}}],["角落虽小",{"2":{"8":1}}],["社交媒体",{"2":{"8":1}}],["乐于分享思考过程",{"2":{"7":1}}],["乐乎",{"2":{"1":1}}],["开源",{"2":{"69":1}}],["开发模型中的测试",{"2":{"43":1}}],["开发重心也转向了移动端app",{"2":{"1":1}}],["开放分享",{"2":{"7":1}}],["真诚至上",{"2":{"7":1}}],["🌐",{"2":{"8":1}}],["🌟",{"0":{"7":1}}],["🍂",{"0":{"1":1}}],["个人经历中的失败",{"2":{"6":1}}],["迭代成长",{"0":{"6":1}}],["艺术带来的创作启发",{"2":{"5":1}}],["音乐",{"2":{"5":1}}],["灵感源泉",{"0":{"5":1}}],["整理零散的思考片段",{"2":{"4":1}}],["捕捉转瞬即逝的想法",{"2":{"4":1}}],["思考",{"2":{"19":1}}],["思维碎片",{"0":{"4":1}}],["思绪思维的空间",{"2":{"1":1}}],["📱",{"2":{"8":1}}],["💫",{"0":{"8":1}}],["📝",{"0":{"3":1},"1":{"4":1,"5":1,"6":1}}],["📖",{"0":{"2":1}}],["你好",{"2":{"2":1}}],["一种方案",{"0":{"158":1}}],["一共5把",{"2":{"157":1}}],["一直自旋",{"2":{"130":1}}],["一直无法获得锁",{"2":{"126":1}}],["一些辅助函数",{"2":{"157":1}}],["一些平台提供了实现临界区的一对指令",{"2":{"133":1}}],["一些例子包括设置栈大小",{"2":{"118":1}}],["一些耗时较少的潜在资源消费者排在重量级的资源消费者之后",{"2":{"94":1}}],["一定不能由多个线程同时执行",{"2":{"115":1}}],["一旦一个读者获得了读锁",{"2":{"156":1}}],["一旦如此",{"2":{"133":1}}],["一旦工作用完了其在某一层中的时间配额",{"2":{"108":1}}],["一旦进入内核模式",{"2":{"89":1}}],["一个负责队列头",{"2":{"145":1}}],["一个贪婪的程序可能在它开始时就调用lock",{"2":{"127":1}}],["一个贪婪的进程可能给自己非常多的彩票",{"2":{"110":1}}],["一个线程可能一直处于让出的循环",{"2":{"136":1}}],["一个线程调用lock",{"2":{"136":1}}],["一个线程会一直自旋检查一个不会改变的值",{"2":{"135":1}}],["一个线程自旋等待标志被设置为",{"2":{"133":1}}],["一个线程检查变量ready是否已经被设置为0以外的值",{"2":{"121":1}}],["一个线程在继续之间必须等待另一个线程完成某些操作",{"2":{"117":1}}],["一个确定性的公平分配算法",{"2":{"112":1}}],["一个列表",{"2":{"111":1}}],["一个记录系统中所有进程的数据结构",{"2":{"111":1}}],["一个记录我所思所想",{"2":{"0":1}}],["一个随机数生成器选择中奖彩票",{"2":{"111":1}}],["一个计算密集型的程序可能在某段时间表现为一个交互型的程序",{"2":{"103":1}}],["一个工作只能存在于一个工作中",{"2":{"100":1}}],["一个进程可以临时提升或降低自己拥有的彩票数量",{"2":{"110":1}}],["一个进程可以临时将自己的彩票交给另一个进程",{"2":{"110":1}}],["一个进程拥有的彩票数占总彩票数的百分比",{"2":{"109":1}}],["一个进程在等待另一个进程的i",{"2":{"99":1}}],["一个进程执行了某种操作",{"2":{"83":1}}],["一个进程只是一个正在运行的程序",{"2":{"76":1}}],["一个多边平台商业模式",{"0":{"68":1}}],["一个多变平台的假体提升在于它所吸引的用户数量的增加",{"2":{"63":1}}],["一词做了专业细分",{"2":{"58":1}}],["一隅之地",{"2":{"1":1}}],["于是父线程将信号量从1减为0",{"2":{"154":1}}],["于是",{"2":{"1":1}}],["cwhile",{"2":{"157":1}}],["csem",{"2":{"155":1}}],["css",{"2":{"1":1}}],["ccond",{"2":{"149":1}}],["ctypedef",{"2":{"141":1}}],["cvoid",{"2":{"136":1,"143":1,"158":1}}],["c语言伪代码",{"2":{"132":1}}],["cpthread",{"2":{"121":2}}],["cpu",{"2":{"108":1,"136":1}}],["cint",{"2":{"120":1,"121":1,"132":1,"148":1}}],["cmov",{"2":{"115":1}}],["c从未运行过一样",{"2":{"87":1}}],["c运行wc",{"2":{"87":1}}],["c",{"2":{"85":1,"86":1,"87":2,"114":1,"118":1,"141":15,"146":1,"152":1,"157":1}}],["c程序使用栈存放局部变量",{"2":{"80":1}}],["create",{"2":{"77":1,"114":2,"118":1}}],["child",{"2":{"85":2,"86":1,"87":1}}],["chapter",{"2":{"87":1}}],["char",{"2":{"85":1,"86":1,"87":2,"114":3,"155":1}}],["changhai",{"2":{"49":1}}],["check",{"2":{"14":1,"24":1}}],["curr",{"2":{"143":5}}],["currency",{"2":{"110":1}}],["current",{"2":{"9":1}}],["custom",{"0":{"23":1}}],["covering",{"0":{"151":1}}],["coupling",{"2":{"144":1}}],["count==1",{"2":{"148":1,"149":1}}],["count==0",{"2":{"148":1,"149":1}}],["count=1",{"2":{"148":1}}],["counter=",{"2":{"114":1}}],["counter=counter+1",{"2":{"114":1}}],["counter",{"2":{"114":4,"141":6}}],["count",{"2":{"87":1,"148":2}}],["compareandswap",{"2":{"132":1}}],["communication",{"2":{"31":1}}],["cookpad食谱网站",{"0":{"72":1}}],["consumer",{"2":{"149":1,"155":1}}],["const",{"2":{"9":1,"118":1}}],["cond",{"2":{"121":14,"149":6,"151":2}}],["conditional",{"2":{"133":1}}],["conditional可以用来配合使用",{"2":{"133":1}}],["condition",{"0":{"121":1,"151":1},"2":{"147":2}}],["context",{"2":{"84":1,"93":1}}],["control",{"2":{"77":1}}],["containers",{"0":{"23":1}}],["concepts",{"2":{"57":1}}],["cornernote",{"2":{"8":1}}],["corner",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1},"2":{"0":1,"1":1,"8":2}}],["can",{"2":{"9":1}}],["这取决于发信号的语义",{"2":{"150":1}}],["这两个锁使得入队列操作和出队列操作可以并发执行",{"2":{"145":1}}],["这个互斥量是已上锁状态",{"2":{"147":1}}],["这个锁变量保存了锁在某一时刻的状态",{"2":{"123":1}}],["这个属性保证了如果一个线程在临界区内执行",{"2":{"115":1}}],["这个例子假定",{"2":{"115":1}}],["这种情况下",{"2":{"153":1}}],["这种并发的方案也不一定会比单锁的方案快",{"2":{"144":1}}],["这种局部转全局的频度",{"2":{"142":1}}],["这种既指就没什么意义",{"2":{"110":1}}],["这种被所有人远远地抛在后面",{"2":{"1":1}}],["这时调度程序应该在cpu上安排另一项工作",{"2":{"99":1}}],["这可能导致显著的性能成本",{"2":{"98":1}}],["这样做确保了所有应该唤醒的线程都被唤醒",{"2":{"151":1}}],["这样做会导致处理器引发异常",{"2":{"89":1}}],["这样消费者再也不会唤醒消费者",{"2":{"149":1}}],["这样可以增加并发",{"2":{"124":1}}],["这样",{"2":{"123":1}}],["这样一来",{"2":{"93":1}}],["这是交互型进程的可能行为",{"2":{"100":1}}],["这是一个性能指标",{"2":{"94":1}}],["这是基本的直接执行协议",{"2":{"88":1}}],["这是我为数不多的擅长的技术",{"2":{"1":1}}],["这些通过映射建立的共同知识",{"2":{"62":1}}],["这里存放着我的日常随笔",{"2":{"17":1}}],["这很好",{"2":{"1":1}}],["甚至命令行",{"2":{"1":1}}],["甚至想要逃离这个困住我的专业",{"2":{"1":1}}],["纷繁复杂的功能也大多只放在了移动端",{"2":{"1":1}}],["但在执行中并没有强制实现原子性",{"2":{"160":1}}],["但给代码加锁没用",{"2":{"148":1}}],["但是又不会有进展",{"2":{"168":1}}],["但是实际运行中却不是这个顺序",{"2":{"161":1}}],["但是实际上在遍历的时候",{"2":{"144":1}}],["但是子线程没有运行",{"2":{"154":1}}],["但是全局计数器与实际计数的偏差越大",{"2":{"142":1}}],["但是",{"2":{"142":1,"156":1}}],["但这种方法仍然成本很高",{"2":{"136":1}}],["但这次被存储在该进程的进程结构的内存中",{"2":{"93":1}}],["但它们共享地址空间",{"2":{"113":1}}],["但它从fork",{"2":{"85":1}}],["但不是确定的",{"2":{"109":1}}],["但如果周转时间是指标",{"2":{"98":1}}],["但由于某种原因",{"2":{"83":1}}],["但由于在这最近十年内",{"2":{"1":1}}],["但我仅仅是用它来发表一些同人文",{"2":{"1":1}}],["它最终调用",{"2":{"153":1}}],["它时互斥量",{"2":{"147":1}}],["它能原子地返回特定地址的旧值",{"2":{"134":1}}],["它会以轮转的方式",{"2":{"105":1}}],["它根据观察到的行为调整优先级",{"2":{"100":1}}],["它被阻塞等待i",{"2":{"99":1}}],["它们饿死了",{"2":{"103":1}}],["它们在cpu高速缓存",{"2":{"98":1}}],["它们和我最初想要建设的",{"2":{"1":1}}],["它反复执行",{"2":{"98":1}}],["它就会确认剩余工作和新工作中",{"2":{"96":1}}],["它什么都不干",{"2":{"91":1}}],["它没有创建新进程",{"2":{"87":1}}],["它针对源代码文件p3",{"2":{"87":1}}],["它的寄存器将被保存到这个内存位置",{"2":{"84":1}}],["它的中文名也许可以被叫作隅言",{"2":{"1":1}}],["它具有哪些危害",{"0":{"27":1},"1":{"28":1,"29":1}}],["它已经从个人博客的平台转型成为了同人作品创作交流分享甚至一种新型社交的网站",{"2":{"1":1}}],["博客",{"2":{"1":1,"8":1}}],["的职责是释放锁",{"2":{"147":1}}],["的代码片段",{"2":{"115":1}}],["的代码序列在x86中看起来像这样",{"2":{"115":1}}],["的值被存回内存中相同的地址",{"2":{"115":1}}],["的文件",{"2":{"103":1}}],["的进程经常运行",{"2":{"99":1}}],["的政策",{"2":{"98":1}}],["的上下文",{"2":{"93":2}}],["的成功调用永远不会返回",{"2":{"87":1}}],["的知识社区",{"2":{"73":1}}],["的游戏营销活动",{"2":{"73":1}}],["的用户会为增值服务付费",{"2":{"69":1}}],["的理念很接近我设想的",{"2":{"1":1}}],["的话",{"2":{"1":1}}],["所有锁必须正确初始化",{"2":{"120":1}}],["所有现代操作系统都以某种形式提供这些api",{"2":{"77":1}}],["所以不会出现每个哲学家都拿着一个餐叉",{"2":{"158":1}}],["所以可以将信号量作为条件变量",{"2":{"154":1}}],["所以先要初始化信号量",{"2":{"152":1}}],["所以这种条件变量叫做覆盖条件",{"2":{"151":1}}],["所以这也可以当做是我的一家之言",{"2":{"1":1}}],["所以计数器的更新操作可扩展性好",{"2":{"142":1}}],["所以需要传入一个指向该值的指针",{"2":{"119":1}}],["所以它被定义为返回一个指向void的指针",{"2":{"119":1}}],["所以我开始找寻一个能够安放我所有的喜怒哀乐",{"2":{"1":1}}],["所爱所厌的小角落",{"2":{"0":1}}],["尤其讨厌我自己",{"2":{"1":1}}],["讨厌一切",{"2":{"1":1}}],["拿到梦中情岗的offer",{"2":{"1":1}}],["不适用于封装",{"2":{"167":1}}],["不会唤醒其他线程",{"2":{"153":1}}],["不满足时",{"2":{"147":1}}],["不满足规格说明",{"2":{"60":1}}],["不论哪种情况",{"2":{"132":1}}],["不支持多处理器",{"2":{"127":1}}],["不能再指令中间中断",{"2":{"116":1}}],["不可控的调度",{"0":{"115":1}}],["不需要餐叉",{"2":{"157":1}}],["不需要担心竞争条件和其他并发缺陷",{"2":{"143":1}}],["不需要全局状态",{"2":{"112":1}}],["不需要我搭建后端数据库",{"2":{"1":1}}],["不需要我买域名",{"2":{"1":1}}],["不需要我租服务器",{"2":{"1":1}}],["不运行b",{"2":{"100":1}}],["不是返回到之前运行的进程",{"2":{"93":1}}],["不断拓展平台边界",{"2":{"74":1}}],["不到10",{"2":{"69":1}}],["不付费客户所得到的财务支持来自于另一个客户群体",{"2":{"67":1}}],["不懈努力",{"2":{"50":1}}],["不同的数据结构访问可能需要不同类型的锁",{"2":{"156":1}}],["不同cpu上的线程不会竞争",{"2":{"142":1}}],["不同实现",{"0":{"138":1}}],["不同操作系统",{"0":{"138":1}}],["不同方面测试",{"2":{"32":1}}],["不同测试技术",{"2":{"32":1}}],["不同应用软件的测试",{"2":{"32":1}}],["不同阶段的测试",{"2":{"32":1}}],["不易使用",{"2":{"28":1}}],["不免有些令人唏嘘",{"2":{"1":1}}],["不写代码不行吗",{"2":{"1":1}}],["不考研不行吗",{"2":{"1":1}}],["寝食难安",{"2":{"1":1}}],["只需要用新进程的票数更新全局的总票数就可以了",{"2":{"112":1}}],["只有在更新共享列表时需要持有锁",{"2":{"143":1}}],["只有硬件支持是不够的",{"2":{"135":1}}],["只有上一次加载的地址在期间都没有更新时",{"2":{"133":1}}],["只有当工作执行非常多的时间片时",{"2":{"111":1}}],["只有我依旧在踌躇不前",{"2":{"1":1}}],["只要进程用完了自己的配额",{"2":{"107":1}}],["只运行每个工作一小段时间",{"2":{"98":1}}],["只是自旋并等待一个线程释放锁",{"2":{"135":1}}],["只是将控制权交给操作系统",{"2":{"91":1}}],["只是最初苦于国内互联网的博客文化已经日渐凋敝",{"2":{"1":1}}],["只写真实的想法和感受",{"2":{"7":1}}],["身边的同学有的剑指保研",{"2":{"1":1}}],["而知也无涯",{"2":{"173":1}}],["而这个资源又是下一个线程要申请的",{"2":{"164":1}}],["而这时该工作也被认为是长工作了",{"2":{"102":1}}],["而线程2持有锁l2",{"2":{"162":1}}],["而一位哲学家只有同时拿到了左手边和右手边的两把餐叉",{"2":{"157":1}}],["而出队列只访问head锁",{"2":{"145":1}}],["而其他线程反复进出临界区",{"2":{"136":1}}],["而信号调用仅需要一个条件",{"2":{"121":1}}],["而不只是该值本身",{"2":{"119":1}}],["而不是整个散列表只有一个锁",{"2":{"146":1}}],["而不是简单的if语句",{"2":{"121":1}}],["而不是确定的计算",{"2":{"115":1}}],["而不是优化周转时间和响应时间",{"2":{"109":1}}],["而不是在调度时重新计时",{"2":{"107":1}}],["而不是运行一个任务直到结束",{"2":{"98":1}}],["而不是想现在这样",{"2":{"1":1}}],["而且得到不同的结果",{"2":{"114":1}}],["而且任务只使用cpu",{"2":{"96":1}}],["而又不会使系统不及时响应",{"2":{"98":1}}],["而唯一的衡量是周转时间",{"2":{"96":1}}],["而是继续执行另一个进程",{"2":{"93":1}}],["而是直接将当前运行的程序",{"2":{"87":1}}],["而是直接从fork",{"2":{"85":1}}],["而子进程获得的返回值是0",{"2":{"85":1}}],["而我在经历本科的学习之后",{"2":{"1":1}}],["而进入大学以后",{"2":{"1":1}}],["我们需要声明一个某种类型的锁变量",{"2":{"123":1}}],["我们真正想要的代码就是所谓的互斥",{"2":{"115":1}}],["我是小c",{"2":{"2":1}}],["我是谁",{"0":{"2":1}}],["我的名字里也带有yu这个音",{"2":{"1":1}}],["我给自己创建了一个角落",{"2":{"1":1}}],["我甚至可以用vue框架",{"2":{"1":1}}],["我只需要一些简单的html",{"2":{"1":1}}],["我发现我可以利用github",{"2":{"1":1}}],["我发现我原本和别人说的",{"2":{"1":1}}],["我有了一些勉强够用的技术",{"2":{"1":1}}],["我曾经很喜欢它网页版个人主页的一些风格模板",{"2":{"1":1}}],["我在乐乎上有账号",{"2":{"1":1}}],["我可以努力地喜欢我正在做的事业",{"2":{"1":1}}],["我当然也想进大厂",{"2":{"1":1}}],["我又不追求进大厂",{"2":{"1":1}}],["我痛苦于未来的规划",{"2":{"1":1}}],["我频繁访问的都是技术性更强的论坛博客",{"2":{"1":1}}],["我很早就有了建设一个个人博客",{"2":{"1":1}}],["隅言",{"2":{"0":1}}]],"serializationVersion":2}';export{t as default};
