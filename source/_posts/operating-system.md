---
title: 操作系统 复习记录
date: 2026-01-13 20:57:29
tags:
    - 学习
    - 操作系统
categories:
    - 大二
---

NXT授课，课程和作业都参考了蒋神的OS课程，不过25年春季课蒋神也对自己的授课顺序进行了一些调整，当时我们的课程安排和作业是和24年及以前的蒋神OS差不多的。如果翘课或者听不懂可以上b站搜索 *@绿导师原谅你了* ，蒋神神了

<!-- more -->


{% quote blue %}
期末考试大纲（NXT的大纲每年可能不一样，仅供参考）：
{% endquote %}

**并发**：互斥、条件变量、信号量、死锁

**虚拟化**：进程和线程、上下⽂切换、fork、execve、exit、调度算法（round-robin时间片轮转算法、FCFS先来先服务、优先级、多级反馈队列）、优先级反转、虚拟内存、TLB、帧替换算法、多级⻚表

**持久化**：驱动程序、DMA、软链接、硬链接、inode多级索引、⽇志、磁盘原理

---
以下是整理的调度算法相关，比较重要


## 调度算法

### 批处理任务的调度

大量的任务

#### 先来先服务（First Come First Serve, FCFS）

按照到达系统（就绪）的先后顺序进行调度，也叫先进先出（FIFO）


**护航效应****：短时间运行的进程排在长运行时间的后面**，导致**平均等待时间过长**的现象

#### 最短任务优先（Shortest Job First,SJF）

将每个任务与其需要运行时间关联（不可判定，可以近似），**需要运行时间最短的优先被调度**


{% quote red %}
就平均等待时间而言，SJF是最优的
{% endquote %}

证明思路

1. 给定一任意进程排列顺序S的平均等待时间
2. 给出一个将给序列变为按执行时间降序排列的过程
3. 证明该过程是单调的，即每一步都会导致平均等待时间变长

#### 最短剩余时间优先（Shortest Remaining Time First, SRTF）

一个**非抢占式**调度算法选择一个进程来运行，然后就让它一直运行，直到它被阻塞（I/O操作或者等待另一个进程）或者资源释放CPU。

而一个**抢占式**调度算法选择一个进程，并允许其运行一段固定的最长时间。如果在时间间隔结束时它仍在运行，则被挂起，调度器选择另一个进程来运行（需要时间中断的机制支持）

<u>最短任务优先的可抢占版本</u>：始终选择剩下需要时间最短的进程进行运行

#### 时间预测算法

- 思想：下一次运行时间应该与之前一次类似

最近的执⾏时间更加影响当前的预测，⽽更之前的执⾏时间则影响较⼩。一般而言，α为0.5

**SJF的缺陷**：并不公平；等待时间差异大：进程饿死；进程的需要运行时间难以给定；以及，可以轻易被愚弄

### 交互性任务的调度

#### 计算密集型（CPU bound）和I/O密集型(I/O bound)

在调度策略中，有两类进程会被区别对待：计算密集型和I/O密集型 （当然也有混合型）

* **CPU密集型**程序主要**消耗CPU计算资源**，例如数学运算、图形处理或数据分析等任务。 这些程序通常会<u>在 CPU 上执⾏⼤部分时间的计算和逻辑判断</u>等操作，⽽<u>不需要等待外部资源（如磁盘读写或⽹络通信）</u>完成。
* **I/O 密集型**指的是**系统⼤部分的时间在等待 I/O**（硬盘/内存/键盘）的**读取/写⼊操作**（即和**外界进⾏频繁交互的进程**），此时 CPU 负载并不⾼，<u>需要消耗CPU计算的时间很少</u>

#### 时间片轮转调度（Round-Robin, RR）

每个任务都会获得一段固定时间的资源（**时间片，time-slicing**），如果任务没有完成，它将重新回到队列中

{% quote blue %}
时间片应该对于切换上下文时间较大，否则开销会太高。一般为10ms-100ms，context switch一般小于10ms
{% endquote %}

平均周转时间较长，且有较高的overhead

#### 基于优先级的调度 Priority Scheduling

I/O-bound和CPU-bound的优先级不同，我⻔需要**基于优先级的调度**

* 每个进程都**关联有⼀个优先级数**（整数）
* 每次发⽣调度时，CPU**被分配给具有最⾼优先级的进程**。

{% quote blue %}
SJF（Shortest Job First）就可以看成是⼀种优先级调度算法，其中每个进程的优先级与预测其下⼀个CPU执⾏时间的倒数成正⽐。
{% endquote %}

Linux下默认的优先级（转换之后）：

1. 实时任务（real time）高优先级（0-99）
2. 普通任务（normal ones）低优先级（100-139）

**优先级调度的问题：**

饿死（Starvation）- 低优先级的进程可能永远不会执行

解决方案：老化（Aging）- 随着时间的推移增加进程的优先级。需要一种能动态改变优先级的策略，如多级反馈队列

#### 多级反馈队列 Multilevel Feedback Queue, MFQ

⼀个进程可以在各个队列（代表不同优先级）之间移动。

多级反馈队列调度器由以下参数定义：

* 队列的数量
* 每个队列的调度算法
* 确定何时将进程提升优先级的⽅法
* 确定何时将进程降优先级的⽅法
* 确定当某个进程需要服务时该将进⼊哪个队列的⽅法

一个典型的多级反馈队列

* 一组轮转队列：每个队列有独立的优先级
* 高优先级队列拥有短的时间片，低优先级队列有长的时间片
* 调度器选择高优先级队列中的第一个进程
* 进程加载到内存中时初始在最高优先级队列中
* 如果时间片到期，任务会降低一个级别



**CPU密集型进程将下沉到长时间片的优先级队列**：如果使用完时间片，进程会下降一个优先级。较大的时间片可以减少上下文切换的开销

**I/O密集型进程将保持在高优先级队列中**：如果一个进程没有完成其时间片（即，它在I/O操作上被阻塞），那么它将保持在相同的优先级水平

* **依旧存在饥饿问题：** 如果有大量交互式进程或者频繁创建新进程
* **一个交互式进程可能会最终处于低优先级水平**

因此，MFQ需要⼀个策略（⽼化）来定期增加进程的优先级，以确保它会被调度运⾏。⼀个简单的⽅法是<u>定期将所有进程提升到最⾼优先级队列</u>，即重置